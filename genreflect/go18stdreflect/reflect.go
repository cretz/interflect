// Code generated by genreflect. DO NOT EDIT.

package go18stdreflect

import (
	"archive/tar"
	"archive/zip"
	"bufio"
	"bytes"
	"compress/bzip2"
	"compress/flate"
	"compress/gzip"
	"compress/lzw"
	"compress/zlib"
	"container/heap"
	"container/list"
	"container/ring"
	"context"
	"crypto"
	"crypto/aes"
	"crypto/cipher"
	"crypto/des"
	"crypto/dsa"
	"crypto/ecdsa"
	"crypto/ed25519"
	"crypto/elliptic"
	"crypto/hmac"
	"crypto/md5"
	"crypto/rand"
	"crypto/rc4"
	"crypto/rsa"
	"crypto/sha1"
	"crypto/sha256"
	"crypto/sha512"
	"crypto/subtle"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"database/sql"
	"database/sql/driver"
	"debug/buildinfo"
	"debug/dwarf"
	"debug/elf"
	"debug/gosym"
	"debug/macho"
	"debug/pe"
	"debug/plan9obj"
	"embed"
	"encoding"
	"encoding/ascii85"
	"encoding/asn1"
	"encoding/base32"
	"encoding/base64"
	"encoding/binary"
	"encoding/csv"
	"encoding/gob"
	"encoding/hex"
	"encoding/json"
	"encoding/pem"
	"encoding/xml"
	"errors"
	"expvar"
	"flag"
	"fmt"
	"go/ast"
	"go/build"
	"go/build/constraint"
	"go/constant"
	"go/doc"
	"go/format"
	"go/importer"
	"go/parser"
	"go/printer"
	"go/scanner"
	"go/token"
	"go/types"
	"hash"
	"hash/adler32"
	"hash/crc32"
	"hash/crc64"
	"hash/fnv"
	"hash/maphash"
	"html"
	"html/template"
	"image"
	"image/color"
	"image/color/palette"
	"image/draw"
	"image/gif"
	"image/jpeg"
	"image/png"
	"index/suffixarray"
	"io"
	"io/fs"
	"io/ioutil"
	"log"
	"math"
	"math/big"
	"math/bits"
	"math/cmplx"
	rand1 "math/rand"
	"mime"
	"mime/multipart"
	"mime/quotedprintable"
	"net"
	"net/http"
	"net/http/cgi"
	"net/http/cookiejar"
	"net/http/fcgi"
	"net/http/httptest"
	"net/http/httptrace"
	"net/http/httputil"
	"net/http/pprof"
	"net/mail"
	"net/netip"
	"net/rpc"
	"net/rpc/jsonrpc"
	"net/smtp"
	"net/textproto"
	"net/url"
	"os"
	"os/exec"
	"os/signal"
	"os/user"
	"path"
	"path/filepath"
	"plugin"
	"reflect"
	"regexp"
	"regexp/syntax"
	"runtime"
	"runtime/debug"
	"runtime/metrics"
	pprof1 "runtime/pprof"
	"runtime/trace"
	"sort"
	"strconv"
	"strings"
	"sync"
	"sync/atomic"
	"testing"
	"testing/fstest"
	"testing/iotest"
	"testing/quick"
	scanner1 "text/scanner"
	"text/tabwriter"
	template1 "text/template"
	"text/template/parse"
	"time"
	"unicode"
	"unicode/utf16"
	"unicode/utf8"
)

// Reflector implements interflect.PackageReflector
func Reflector() reflector { return reflector{} }

type reflector struct{}

func (reflector) ReflectType(pkgName, topLevelName string) reflect.Type {
	switch pkgName {
	case "archive/tar":
		switch topLevelName {
		case "Format":
			return reflect.TypeOf((*tar.Format)(nil)).Elem()
		case "Header":
			return reflect.TypeOf((*tar.Header)(nil)).Elem()
		case "Reader":
			return reflect.TypeOf((*tar.Reader)(nil)).Elem()
		case "Writer":
			return reflect.TypeOf((*tar.Writer)(nil)).Elem()
		}
	case "archive/zip":
		switch topLevelName {
		case "Compressor":
			return reflect.TypeOf((*zip.Compressor)(nil)).Elem()
		case "Decompressor":
			return reflect.TypeOf((*zip.Decompressor)(nil)).Elem()
		case "File":
			return reflect.TypeOf((*zip.File)(nil)).Elem()
		case "FileHeader":
			return reflect.TypeOf((*zip.FileHeader)(nil)).Elem()
		case "ReadCloser":
			return reflect.TypeOf((*zip.ReadCloser)(nil)).Elem()
		case "Reader":
			return reflect.TypeOf((*zip.Reader)(nil)).Elem()
		case "Writer":
			return reflect.TypeOf((*zip.Writer)(nil)).Elem()
		}
	case "bufio":
		switch topLevelName {
		case "ReadWriter":
			return reflect.TypeOf((*bufio.ReadWriter)(nil)).Elem()
		case "Reader":
			return reflect.TypeOf((*bufio.Reader)(nil)).Elem()
		case "Scanner":
			return reflect.TypeOf((*bufio.Scanner)(nil)).Elem()
		case "SplitFunc":
			return reflect.TypeOf((*bufio.SplitFunc)(nil)).Elem()
		case "Writer":
			return reflect.TypeOf((*bufio.Writer)(nil)).Elem()
		}
	case "bytes":
		switch topLevelName {
		case "Buffer":
			return reflect.TypeOf((*bytes.Buffer)(nil)).Elem()
		case "Reader":
			return reflect.TypeOf((*bytes.Reader)(nil)).Elem()
		}
	case "compress/bzip2":
		switch topLevelName {
		case "StructuralError":
			return reflect.TypeOf((*bzip2.StructuralError)(nil)).Elem()
		}
	case "compress/flate":
		switch topLevelName {
		case "CorruptInputError":
			return reflect.TypeOf((*flate.CorruptInputError)(nil)).Elem()
		case "InternalError":
			return reflect.TypeOf((*flate.InternalError)(nil)).Elem()
		case "ReadError":
			return reflect.TypeOf((*flate.ReadError)(nil)).Elem()
		case "Reader":
			return reflect.TypeOf((*flate.Reader)(nil)).Elem()
		case "Resetter":
			return reflect.TypeOf((*flate.Resetter)(nil)).Elem()
		case "WriteError":
			return reflect.TypeOf((*flate.WriteError)(nil)).Elem()
		case "Writer":
			return reflect.TypeOf((*flate.Writer)(nil)).Elem()
		}
	case "compress/gzip":
		switch topLevelName {
		case "Header":
			return reflect.TypeOf((*gzip.Header)(nil)).Elem()
		case "Reader":
			return reflect.TypeOf((*gzip.Reader)(nil)).Elem()
		case "Writer":
			return reflect.TypeOf((*gzip.Writer)(nil)).Elem()
		}
	case "compress/lzw":
		switch topLevelName {
		case "Order":
			return reflect.TypeOf((*lzw.Order)(nil)).Elem()
		case "Reader":
			return reflect.TypeOf((*lzw.Reader)(nil)).Elem()
		case "Writer":
			return reflect.TypeOf((*lzw.Writer)(nil)).Elem()
		}
	case "compress/zlib":
		switch topLevelName {
		case "Resetter":
			return reflect.TypeOf((*zlib.Resetter)(nil)).Elem()
		case "Writer":
			return reflect.TypeOf((*zlib.Writer)(nil)).Elem()
		}
	case "container/heap":
		switch topLevelName {
		case "Interface":
			return reflect.TypeOf((*heap.Interface)(nil)).Elem()
		}
	case "container/list":
		switch topLevelName {
		case "Element":
			return reflect.TypeOf((*list.Element)(nil)).Elem()
		case "List":
			return reflect.TypeOf((*list.List)(nil)).Elem()
		}
	case "container/ring":
		switch topLevelName {
		case "Ring":
			return reflect.TypeOf((*ring.Ring)(nil)).Elem()
		}
	case "context":
		switch topLevelName {
		case "CancelFunc":
			return reflect.TypeOf((*context.CancelFunc)(nil)).Elem()
		case "Context":
			return reflect.TypeOf((*context.Context)(nil)).Elem()
		}
	case "crypto":
		switch topLevelName {
		case "Decrypter":
			return reflect.TypeOf((*crypto.Decrypter)(nil)).Elem()
		case "DecrypterOpts":
			return reflect.TypeOf((*crypto.DecrypterOpts)(nil)).Elem()
		case "Hash":
			return reflect.TypeOf((*crypto.Hash)(nil)).Elem()
		case "PrivateKey":
			return reflect.TypeOf((*crypto.PrivateKey)(nil)).Elem()
		case "PublicKey":
			return reflect.TypeOf((*crypto.PublicKey)(nil)).Elem()
		case "Signer":
			return reflect.TypeOf((*crypto.Signer)(nil)).Elem()
		case "SignerOpts":
			return reflect.TypeOf((*crypto.SignerOpts)(nil)).Elem()
		}
	case "crypto/aes":
		switch topLevelName {
		case "KeySizeError":
			return reflect.TypeOf((*aes.KeySizeError)(nil)).Elem()
		}
	case "crypto/cipher":
		switch topLevelName {
		case "AEAD":
			return reflect.TypeOf((*cipher.AEAD)(nil)).Elem()
		case "Block":
			return reflect.TypeOf((*cipher.Block)(nil)).Elem()
		case "BlockMode":
			return reflect.TypeOf((*cipher.BlockMode)(nil)).Elem()
		case "Stream":
			return reflect.TypeOf((*cipher.Stream)(nil)).Elem()
		case "StreamReader":
			return reflect.TypeOf((*cipher.StreamReader)(nil)).Elem()
		case "StreamWriter":
			return reflect.TypeOf((*cipher.StreamWriter)(nil)).Elem()
		}
	case "crypto/des":
		switch topLevelName {
		case "KeySizeError":
			return reflect.TypeOf((*des.KeySizeError)(nil)).Elem()
		}
	case "crypto/dsa":
		switch topLevelName {
		case "ParameterSizes":
			return reflect.TypeOf((*dsa.ParameterSizes)(nil)).Elem()
		case "Parameters":
			return reflect.TypeOf((*dsa.Parameters)(nil)).Elem()
		case "PrivateKey":
			return reflect.TypeOf((*dsa.PrivateKey)(nil)).Elem()
		case "PublicKey":
			return reflect.TypeOf((*dsa.PublicKey)(nil)).Elem()
		}
	case "crypto/ecdsa":
		switch topLevelName {
		case "PrivateKey":
			return reflect.TypeOf((*ecdsa.PrivateKey)(nil)).Elem()
		case "PublicKey":
			return reflect.TypeOf((*ecdsa.PublicKey)(nil)).Elem()
		}
	case "crypto/ed25519":
		switch topLevelName {
		case "PrivateKey":
			return reflect.TypeOf((*ed25519.PrivateKey)(nil)).Elem()
		case "PublicKey":
			return reflect.TypeOf((*ed25519.PublicKey)(nil)).Elem()
		}
	case "crypto/elliptic":
		switch topLevelName {
		case "Curve":
			return reflect.TypeOf((*elliptic.Curve)(nil)).Elem()
		case "CurveParams":
			return reflect.TypeOf((*elliptic.CurveParams)(nil)).Elem()
		}
	case "crypto/rc4":
		switch topLevelName {
		case "Cipher":
			return reflect.TypeOf((*rc4.Cipher)(nil)).Elem()
		case "KeySizeError":
			return reflect.TypeOf((*rc4.KeySizeError)(nil)).Elem()
		}
	case "crypto/rsa":
		switch topLevelName {
		case "CRTValue":
			return reflect.TypeOf((*rsa.CRTValue)(nil)).Elem()
		case "OAEPOptions":
			return reflect.TypeOf((*rsa.OAEPOptions)(nil)).Elem()
		case "PKCS1v15DecryptOptions":
			return reflect.TypeOf((*rsa.PKCS1v15DecryptOptions)(nil)).Elem()
		case "PSSOptions":
			return reflect.TypeOf((*rsa.PSSOptions)(nil)).Elem()
		case "PrecomputedValues":
			return reflect.TypeOf((*rsa.PrecomputedValues)(nil)).Elem()
		case "PrivateKey":
			return reflect.TypeOf((*rsa.PrivateKey)(nil)).Elem()
		case "PublicKey":
			return reflect.TypeOf((*rsa.PublicKey)(nil)).Elem()
		}
	case "crypto/tls":
		switch topLevelName {
		case "Certificate":
			return reflect.TypeOf((*tls.Certificate)(nil)).Elem()
		case "CertificateRequestInfo":
			return reflect.TypeOf((*tls.CertificateRequestInfo)(nil)).Elem()
		case "CipherSuite":
			return reflect.TypeOf((*tls.CipherSuite)(nil)).Elem()
		case "ClientAuthType":
			return reflect.TypeOf((*tls.ClientAuthType)(nil)).Elem()
		case "ClientHelloInfo":
			return reflect.TypeOf((*tls.ClientHelloInfo)(nil)).Elem()
		case "ClientSessionCache":
			return reflect.TypeOf((*tls.ClientSessionCache)(nil)).Elem()
		case "ClientSessionState":
			return reflect.TypeOf((*tls.ClientSessionState)(nil)).Elem()
		case "Config":
			return reflect.TypeOf((*tls.Config)(nil)).Elem()
		case "Conn":
			return reflect.TypeOf((*tls.Conn)(nil)).Elem()
		case "ConnectionState":
			return reflect.TypeOf((*tls.ConnectionState)(nil)).Elem()
		case "CurveID":
			return reflect.TypeOf((*tls.CurveID)(nil)).Elem()
		case "Dialer":
			return reflect.TypeOf((*tls.Dialer)(nil)).Elem()
		case "RecordHeaderError":
			return reflect.TypeOf((*tls.RecordHeaderError)(nil)).Elem()
		case "RenegotiationSupport":
			return reflect.TypeOf((*tls.RenegotiationSupport)(nil)).Elem()
		case "SignatureScheme":
			return reflect.TypeOf((*tls.SignatureScheme)(nil)).Elem()
		}
	case "crypto/x509":
		switch topLevelName {
		case "CertPool":
			return reflect.TypeOf((*x509.CertPool)(nil)).Elem()
		case "Certificate":
			return reflect.TypeOf((*x509.Certificate)(nil)).Elem()
		case "CertificateInvalidError":
			return reflect.TypeOf((*x509.CertificateInvalidError)(nil)).Elem()
		case "CertificateRequest":
			return reflect.TypeOf((*x509.CertificateRequest)(nil)).Elem()
		case "ConstraintViolationError":
			return reflect.TypeOf((*x509.ConstraintViolationError)(nil)).Elem()
		case "ExtKeyUsage":
			return reflect.TypeOf((*x509.ExtKeyUsage)(nil)).Elem()
		case "HostnameError":
			return reflect.TypeOf((*x509.HostnameError)(nil)).Elem()
		case "InsecureAlgorithmError":
			return reflect.TypeOf((*x509.InsecureAlgorithmError)(nil)).Elem()
		case "InvalidReason":
			return reflect.TypeOf((*x509.InvalidReason)(nil)).Elem()
		case "KeyUsage":
			return reflect.TypeOf((*x509.KeyUsage)(nil)).Elem()
		case "PEMCipher":
			return reflect.TypeOf((*x509.PEMCipher)(nil)).Elem()
		case "PublicKeyAlgorithm":
			return reflect.TypeOf((*x509.PublicKeyAlgorithm)(nil)).Elem()
		case "RevocationList":
			return reflect.TypeOf((*x509.RevocationList)(nil)).Elem()
		case "SignatureAlgorithm":
			return reflect.TypeOf((*x509.SignatureAlgorithm)(nil)).Elem()
		case "SystemRootsError":
			return reflect.TypeOf((*x509.SystemRootsError)(nil)).Elem()
		case "UnhandledCriticalExtension":
			return reflect.TypeOf((*x509.UnhandledCriticalExtension)(nil)).Elem()
		case "UnknownAuthorityError":
			return reflect.TypeOf((*x509.UnknownAuthorityError)(nil)).Elem()
		case "VerifyOptions":
			return reflect.TypeOf((*x509.VerifyOptions)(nil)).Elem()
		}
	case "crypto/x509/pkix":
		switch topLevelName {
		case "AlgorithmIdentifier":
			return reflect.TypeOf((*pkix.AlgorithmIdentifier)(nil)).Elem()
		case "AttributeTypeAndValue":
			return reflect.TypeOf((*pkix.AttributeTypeAndValue)(nil)).Elem()
		case "AttributeTypeAndValueSET":
			return reflect.TypeOf((*pkix.AttributeTypeAndValueSET)(nil)).Elem()
		case "CertificateList":
			return reflect.TypeOf((*pkix.CertificateList)(nil)).Elem()
		case "Extension":
			return reflect.TypeOf((*pkix.Extension)(nil)).Elem()
		case "Name":
			return reflect.TypeOf((*pkix.Name)(nil)).Elem()
		case "RDNSequence":
			return reflect.TypeOf((*pkix.RDNSequence)(nil)).Elem()
		case "RelativeDistinguishedNameSET":
			return reflect.TypeOf((*pkix.RelativeDistinguishedNameSET)(nil)).Elem()
		case "RevokedCertificate":
			return reflect.TypeOf((*pkix.RevokedCertificate)(nil)).Elem()
		case "TBSCertificateList":
			return reflect.TypeOf((*pkix.TBSCertificateList)(nil)).Elem()
		}
	case "database/sql":
		switch topLevelName {
		case "ColumnType":
			return reflect.TypeOf((*sql.ColumnType)(nil)).Elem()
		case "Conn":
			return reflect.TypeOf((*sql.Conn)(nil)).Elem()
		case "DB":
			return reflect.TypeOf((*sql.DB)(nil)).Elem()
		case "DBStats":
			return reflect.TypeOf((*sql.DBStats)(nil)).Elem()
		case "IsolationLevel":
			return reflect.TypeOf((*sql.IsolationLevel)(nil)).Elem()
		case "NamedArg":
			return reflect.TypeOf((*sql.NamedArg)(nil)).Elem()
		case "NullBool":
			return reflect.TypeOf((*sql.NullBool)(nil)).Elem()
		case "NullByte":
			return reflect.TypeOf((*sql.NullByte)(nil)).Elem()
		case "NullFloat64":
			return reflect.TypeOf((*sql.NullFloat64)(nil)).Elem()
		case "NullInt16":
			return reflect.TypeOf((*sql.NullInt16)(nil)).Elem()
		case "NullInt32":
			return reflect.TypeOf((*sql.NullInt32)(nil)).Elem()
		case "NullInt64":
			return reflect.TypeOf((*sql.NullInt64)(nil)).Elem()
		case "NullString":
			return reflect.TypeOf((*sql.NullString)(nil)).Elem()
		case "NullTime":
			return reflect.TypeOf((*sql.NullTime)(nil)).Elem()
		case "Out":
			return reflect.TypeOf((*sql.Out)(nil)).Elem()
		case "RawBytes":
			return reflect.TypeOf((*sql.RawBytes)(nil)).Elem()
		case "Result":
			return reflect.TypeOf((*sql.Result)(nil)).Elem()
		case "Row":
			return reflect.TypeOf((*sql.Row)(nil)).Elem()
		case "Rows":
			return reflect.TypeOf((*sql.Rows)(nil)).Elem()
		case "Scanner":
			return reflect.TypeOf((*sql.Scanner)(nil)).Elem()
		case "Stmt":
			return reflect.TypeOf((*sql.Stmt)(nil)).Elem()
		case "Tx":
			return reflect.TypeOf((*sql.Tx)(nil)).Elem()
		case "TxOptions":
			return reflect.TypeOf((*sql.TxOptions)(nil)).Elem()
		}
	case "database/sql/driver":
		switch topLevelName {
		case "ColumnConverter":
			return reflect.TypeOf((*driver.ColumnConverter)(nil)).Elem()
		case "Conn":
			return reflect.TypeOf((*driver.Conn)(nil)).Elem()
		case "ConnBeginTx":
			return reflect.TypeOf((*driver.ConnBeginTx)(nil)).Elem()
		case "ConnPrepareContext":
			return reflect.TypeOf((*driver.ConnPrepareContext)(nil)).Elem()
		case "Connector":
			return reflect.TypeOf((*driver.Connector)(nil)).Elem()
		case "Driver":
			return reflect.TypeOf((*driver.Driver)(nil)).Elem()
		case "DriverContext":
			return reflect.TypeOf((*driver.DriverContext)(nil)).Elem()
		case "Execer":
			return reflect.TypeOf((*driver.Execer)(nil)).Elem()
		case "ExecerContext":
			return reflect.TypeOf((*driver.ExecerContext)(nil)).Elem()
		case "IsolationLevel":
			return reflect.TypeOf((*driver.IsolationLevel)(nil)).Elem()
		case "NamedValue":
			return reflect.TypeOf((*driver.NamedValue)(nil)).Elem()
		case "NamedValueChecker":
			return reflect.TypeOf((*driver.NamedValueChecker)(nil)).Elem()
		case "NotNull":
			return reflect.TypeOf((*driver.NotNull)(nil)).Elem()
		case "Null":
			return reflect.TypeOf((*driver.Null)(nil)).Elem()
		case "Pinger":
			return reflect.TypeOf((*driver.Pinger)(nil)).Elem()
		case "Queryer":
			return reflect.TypeOf((*driver.Queryer)(nil)).Elem()
		case "QueryerContext":
			return reflect.TypeOf((*driver.QueryerContext)(nil)).Elem()
		case "Result":
			return reflect.TypeOf((*driver.Result)(nil)).Elem()
		case "Rows":
			return reflect.TypeOf((*driver.Rows)(nil)).Elem()
		case "RowsAffected":
			return reflect.TypeOf((*driver.RowsAffected)(nil)).Elem()
		case "RowsColumnTypeDatabaseTypeName":
			return reflect.TypeOf((*driver.RowsColumnTypeDatabaseTypeName)(nil)).Elem()
		case "RowsColumnTypeLength":
			return reflect.TypeOf((*driver.RowsColumnTypeLength)(nil)).Elem()
		case "RowsColumnTypeNullable":
			return reflect.TypeOf((*driver.RowsColumnTypeNullable)(nil)).Elem()
		case "RowsColumnTypePrecisionScale":
			return reflect.TypeOf((*driver.RowsColumnTypePrecisionScale)(nil)).Elem()
		case "RowsColumnTypeScanType":
			return reflect.TypeOf((*driver.RowsColumnTypeScanType)(nil)).Elem()
		case "RowsNextResultSet":
			return reflect.TypeOf((*driver.RowsNextResultSet)(nil)).Elem()
		case "SessionResetter":
			return reflect.TypeOf((*driver.SessionResetter)(nil)).Elem()
		case "Stmt":
			return reflect.TypeOf((*driver.Stmt)(nil)).Elem()
		case "StmtExecContext":
			return reflect.TypeOf((*driver.StmtExecContext)(nil)).Elem()
		case "StmtQueryContext":
			return reflect.TypeOf((*driver.StmtQueryContext)(nil)).Elem()
		case "Tx":
			return reflect.TypeOf((*driver.Tx)(nil)).Elem()
		case "TxOptions":
			return reflect.TypeOf((*driver.TxOptions)(nil)).Elem()
		case "Validator":
			return reflect.TypeOf((*driver.Validator)(nil)).Elem()
		case "Value":
			return reflect.TypeOf((*driver.Value)(nil)).Elem()
		case "ValueConverter":
			return reflect.TypeOf((*driver.ValueConverter)(nil)).Elem()
		case "Valuer":
			return reflect.TypeOf((*driver.Valuer)(nil)).Elem()
		}
	case "debug/buildinfo":
		switch topLevelName {
		case "BuildInfo":
			return reflect.TypeOf((*buildinfo.BuildInfo)(nil)).Elem()
		}
	case "debug/dwarf":
		switch topLevelName {
		case "AddrType":
			return reflect.TypeOf((*dwarf.AddrType)(nil)).Elem()
		case "ArrayType":
			return reflect.TypeOf((*dwarf.ArrayType)(nil)).Elem()
		case "Attr":
			return reflect.TypeOf((*dwarf.Attr)(nil)).Elem()
		case "BasicType":
			return reflect.TypeOf((*dwarf.BasicType)(nil)).Elem()
		case "BoolType":
			return reflect.TypeOf((*dwarf.BoolType)(nil)).Elem()
		case "CharType":
			return reflect.TypeOf((*dwarf.CharType)(nil)).Elem()
		case "Class":
			return reflect.TypeOf((*dwarf.Class)(nil)).Elem()
		case "CommonType":
			return reflect.TypeOf((*dwarf.CommonType)(nil)).Elem()
		case "ComplexType":
			return reflect.TypeOf((*dwarf.ComplexType)(nil)).Elem()
		case "Data":
			return reflect.TypeOf((*dwarf.Data)(nil)).Elem()
		case "DecodeError":
			return reflect.TypeOf((*dwarf.DecodeError)(nil)).Elem()
		case "DotDotDotType":
			return reflect.TypeOf((*dwarf.DotDotDotType)(nil)).Elem()
		case "Entry":
			return reflect.TypeOf((*dwarf.Entry)(nil)).Elem()
		case "EnumType":
			return reflect.TypeOf((*dwarf.EnumType)(nil)).Elem()
		case "EnumValue":
			return reflect.TypeOf((*dwarf.EnumValue)(nil)).Elem()
		case "Field":
			return reflect.TypeOf((*dwarf.Field)(nil)).Elem()
		case "FloatType":
			return reflect.TypeOf((*dwarf.FloatType)(nil)).Elem()
		case "FuncType":
			return reflect.TypeOf((*dwarf.FuncType)(nil)).Elem()
		case "IntType":
			return reflect.TypeOf((*dwarf.IntType)(nil)).Elem()
		case "LineEntry":
			return reflect.TypeOf((*dwarf.LineEntry)(nil)).Elem()
		case "LineFile":
			return reflect.TypeOf((*dwarf.LineFile)(nil)).Elem()
		case "LineReader":
			return reflect.TypeOf((*dwarf.LineReader)(nil)).Elem()
		case "LineReaderPos":
			return reflect.TypeOf((*dwarf.LineReaderPos)(nil)).Elem()
		case "Offset":
			return reflect.TypeOf((*dwarf.Offset)(nil)).Elem()
		case "PtrType":
			return reflect.TypeOf((*dwarf.PtrType)(nil)).Elem()
		case "QualType":
			return reflect.TypeOf((*dwarf.QualType)(nil)).Elem()
		case "Reader":
			return reflect.TypeOf((*dwarf.Reader)(nil)).Elem()
		case "StructField":
			return reflect.TypeOf((*dwarf.StructField)(nil)).Elem()
		case "StructType":
			return reflect.TypeOf((*dwarf.StructType)(nil)).Elem()
		case "Tag":
			return reflect.TypeOf((*dwarf.Tag)(nil)).Elem()
		case "Type":
			return reflect.TypeOf((*dwarf.Type)(nil)).Elem()
		case "TypedefType":
			return reflect.TypeOf((*dwarf.TypedefType)(nil)).Elem()
		case "UcharType":
			return reflect.TypeOf((*dwarf.UcharType)(nil)).Elem()
		case "UintType":
			return reflect.TypeOf((*dwarf.UintType)(nil)).Elem()
		case "UnspecifiedType":
			return reflect.TypeOf((*dwarf.UnspecifiedType)(nil)).Elem()
		case "UnsupportedType":
			return reflect.TypeOf((*dwarf.UnsupportedType)(nil)).Elem()
		case "VoidType":
			return reflect.TypeOf((*dwarf.VoidType)(nil)).Elem()
		}
	case "debug/elf":
		switch topLevelName {
		case "Chdr32":
			return reflect.TypeOf((*elf.Chdr32)(nil)).Elem()
		case "Chdr64":
			return reflect.TypeOf((*elf.Chdr64)(nil)).Elem()
		case "Class":
			return reflect.TypeOf((*elf.Class)(nil)).Elem()
		case "CompressionType":
			return reflect.TypeOf((*elf.CompressionType)(nil)).Elem()
		case "Data":
			return reflect.TypeOf((*elf.Data)(nil)).Elem()
		case "Dyn32":
			return reflect.TypeOf((*elf.Dyn32)(nil)).Elem()
		case "Dyn64":
			return reflect.TypeOf((*elf.Dyn64)(nil)).Elem()
		case "DynFlag":
			return reflect.TypeOf((*elf.DynFlag)(nil)).Elem()
		case "DynTag":
			return reflect.TypeOf((*elf.DynTag)(nil)).Elem()
		case "File":
			return reflect.TypeOf((*elf.File)(nil)).Elem()
		case "FileHeader":
			return reflect.TypeOf((*elf.FileHeader)(nil)).Elem()
		case "FormatError":
			return reflect.TypeOf((*elf.FormatError)(nil)).Elem()
		case "Header32":
			return reflect.TypeOf((*elf.Header32)(nil)).Elem()
		case "Header64":
			return reflect.TypeOf((*elf.Header64)(nil)).Elem()
		case "ImportedSymbol":
			return reflect.TypeOf((*elf.ImportedSymbol)(nil)).Elem()
		case "Machine":
			return reflect.TypeOf((*elf.Machine)(nil)).Elem()
		case "NType":
			return reflect.TypeOf((*elf.NType)(nil)).Elem()
		case "OSABI":
			return reflect.TypeOf((*elf.OSABI)(nil)).Elem()
		case "Prog":
			return reflect.TypeOf((*elf.Prog)(nil)).Elem()
		case "Prog32":
			return reflect.TypeOf((*elf.Prog32)(nil)).Elem()
		case "Prog64":
			return reflect.TypeOf((*elf.Prog64)(nil)).Elem()
		case "ProgFlag":
			return reflect.TypeOf((*elf.ProgFlag)(nil)).Elem()
		case "ProgHeader":
			return reflect.TypeOf((*elf.ProgHeader)(nil)).Elem()
		case "ProgType":
			return reflect.TypeOf((*elf.ProgType)(nil)).Elem()
		case "R_386":
			return reflect.TypeOf((*elf.R_386)(nil)).Elem()
		case "R_390":
			return reflect.TypeOf((*elf.R_390)(nil)).Elem()
		case "R_AARCH64":
			return reflect.TypeOf((*elf.R_AARCH64)(nil)).Elem()
		case "R_ALPHA":
			return reflect.TypeOf((*elf.R_ALPHA)(nil)).Elem()
		case "R_ARM":
			return reflect.TypeOf((*elf.R_ARM)(nil)).Elem()
		case "R_MIPS":
			return reflect.TypeOf((*elf.R_MIPS)(nil)).Elem()
		case "R_PPC":
			return reflect.TypeOf((*elf.R_PPC)(nil)).Elem()
		case "R_PPC64":
			return reflect.TypeOf((*elf.R_PPC64)(nil)).Elem()
		case "R_RISCV":
			return reflect.TypeOf((*elf.R_RISCV)(nil)).Elem()
		case "R_SPARC":
			return reflect.TypeOf((*elf.R_SPARC)(nil)).Elem()
		case "R_X86_64":
			return reflect.TypeOf((*elf.R_X86_64)(nil)).Elem()
		case "Rel32":
			return reflect.TypeOf((*elf.Rel32)(nil)).Elem()
		case "Rel64":
			return reflect.TypeOf((*elf.Rel64)(nil)).Elem()
		case "Rela32":
			return reflect.TypeOf((*elf.Rela32)(nil)).Elem()
		case "Rela64":
			return reflect.TypeOf((*elf.Rela64)(nil)).Elem()
		case "Section":
			return reflect.TypeOf((*elf.Section)(nil)).Elem()
		case "Section32":
			return reflect.TypeOf((*elf.Section32)(nil)).Elem()
		case "Section64":
			return reflect.TypeOf((*elf.Section64)(nil)).Elem()
		case "SectionFlag":
			return reflect.TypeOf((*elf.SectionFlag)(nil)).Elem()
		case "SectionHeader":
			return reflect.TypeOf((*elf.SectionHeader)(nil)).Elem()
		case "SectionIndex":
			return reflect.TypeOf((*elf.SectionIndex)(nil)).Elem()
		case "SectionType":
			return reflect.TypeOf((*elf.SectionType)(nil)).Elem()
		case "Sym32":
			return reflect.TypeOf((*elf.Sym32)(nil)).Elem()
		case "Sym64":
			return reflect.TypeOf((*elf.Sym64)(nil)).Elem()
		case "SymBind":
			return reflect.TypeOf((*elf.SymBind)(nil)).Elem()
		case "SymType":
			return reflect.TypeOf((*elf.SymType)(nil)).Elem()
		case "SymVis":
			return reflect.TypeOf((*elf.SymVis)(nil)).Elem()
		case "Symbol":
			return reflect.TypeOf((*elf.Symbol)(nil)).Elem()
		case "Type":
			return reflect.TypeOf((*elf.Type)(nil)).Elem()
		case "Version":
			return reflect.TypeOf((*elf.Version)(nil)).Elem()
		}
	case "debug/gosym":
		switch topLevelName {
		case "DecodingError":
			return reflect.TypeOf((*gosym.DecodingError)(nil)).Elem()
		case "Func":
			return reflect.TypeOf((*gosym.Func)(nil)).Elem()
		case "LineTable":
			return reflect.TypeOf((*gosym.LineTable)(nil)).Elem()
		case "Obj":
			return reflect.TypeOf((*gosym.Obj)(nil)).Elem()
		case "Sym":
			return reflect.TypeOf((*gosym.Sym)(nil)).Elem()
		case "Table":
			return reflect.TypeOf((*gosym.Table)(nil)).Elem()
		case "UnknownFileError":
			return reflect.TypeOf((*gosym.UnknownFileError)(nil)).Elem()
		case "UnknownLineError":
			return reflect.TypeOf((*gosym.UnknownLineError)(nil)).Elem()
		}
	case "debug/macho":
		switch topLevelName {
		case "Cpu":
			return reflect.TypeOf((*macho.Cpu)(nil)).Elem()
		case "Dylib":
			return reflect.TypeOf((*macho.Dylib)(nil)).Elem()
		case "DylibCmd":
			return reflect.TypeOf((*macho.DylibCmd)(nil)).Elem()
		case "Dysymtab":
			return reflect.TypeOf((*macho.Dysymtab)(nil)).Elem()
		case "DysymtabCmd":
			return reflect.TypeOf((*macho.DysymtabCmd)(nil)).Elem()
		case "FatArch":
			return reflect.TypeOf((*macho.FatArch)(nil)).Elem()
		case "FatArchHeader":
			return reflect.TypeOf((*macho.FatArchHeader)(nil)).Elem()
		case "FatFile":
			return reflect.TypeOf((*macho.FatFile)(nil)).Elem()
		case "File":
			return reflect.TypeOf((*macho.File)(nil)).Elem()
		case "FileHeader":
			return reflect.TypeOf((*macho.FileHeader)(nil)).Elem()
		case "FormatError":
			return reflect.TypeOf((*macho.FormatError)(nil)).Elem()
		case "Load":
			return reflect.TypeOf((*macho.Load)(nil)).Elem()
		case "LoadBytes":
			return reflect.TypeOf((*macho.LoadBytes)(nil)).Elem()
		case "LoadCmd":
			return reflect.TypeOf((*macho.LoadCmd)(nil)).Elem()
		case "Nlist32":
			return reflect.TypeOf((*macho.Nlist32)(nil)).Elem()
		case "Nlist64":
			return reflect.TypeOf((*macho.Nlist64)(nil)).Elem()
		case "Regs386":
			return reflect.TypeOf((*macho.Regs386)(nil)).Elem()
		case "RegsAMD64":
			return reflect.TypeOf((*macho.RegsAMD64)(nil)).Elem()
		case "Reloc":
			return reflect.TypeOf((*macho.Reloc)(nil)).Elem()
		case "RelocTypeARM":
			return reflect.TypeOf((*macho.RelocTypeARM)(nil)).Elem()
		case "RelocTypeARM64":
			return reflect.TypeOf((*macho.RelocTypeARM64)(nil)).Elem()
		case "RelocTypeGeneric":
			return reflect.TypeOf((*macho.RelocTypeGeneric)(nil)).Elem()
		case "RelocTypeX86_64":
			return reflect.TypeOf((*macho.RelocTypeX86_64)(nil)).Elem()
		case "Rpath":
			return reflect.TypeOf((*macho.Rpath)(nil)).Elem()
		case "RpathCmd":
			return reflect.TypeOf((*macho.RpathCmd)(nil)).Elem()
		case "Section":
			return reflect.TypeOf((*macho.Section)(nil)).Elem()
		case "Section32":
			return reflect.TypeOf((*macho.Section32)(nil)).Elem()
		case "Section64":
			return reflect.TypeOf((*macho.Section64)(nil)).Elem()
		case "SectionHeader":
			return reflect.TypeOf((*macho.SectionHeader)(nil)).Elem()
		case "Segment":
			return reflect.TypeOf((*macho.Segment)(nil)).Elem()
		case "Segment32":
			return reflect.TypeOf((*macho.Segment32)(nil)).Elem()
		case "Segment64":
			return reflect.TypeOf((*macho.Segment64)(nil)).Elem()
		case "SegmentHeader":
			return reflect.TypeOf((*macho.SegmentHeader)(nil)).Elem()
		case "Symbol":
			return reflect.TypeOf((*macho.Symbol)(nil)).Elem()
		case "Symtab":
			return reflect.TypeOf((*macho.Symtab)(nil)).Elem()
		case "SymtabCmd":
			return reflect.TypeOf((*macho.SymtabCmd)(nil)).Elem()
		case "Thread":
			return reflect.TypeOf((*macho.Thread)(nil)).Elem()
		case "Type":
			return reflect.TypeOf((*macho.Type)(nil)).Elem()
		}
	case "debug/pe":
		switch topLevelName {
		case "COFFSymbol":
			return reflect.TypeOf((*pe.COFFSymbol)(nil)).Elem()
		case "DataDirectory":
			return reflect.TypeOf((*pe.DataDirectory)(nil)).Elem()
		case "File":
			return reflect.TypeOf((*pe.File)(nil)).Elem()
		case "FileHeader":
			return reflect.TypeOf((*pe.FileHeader)(nil)).Elem()
		case "FormatError":
			return reflect.TypeOf((*pe.FormatError)(nil)).Elem()
		case "ImportDirectory":
			return reflect.TypeOf((*pe.ImportDirectory)(nil)).Elem()
		case "OptionalHeader32":
			return reflect.TypeOf((*pe.OptionalHeader32)(nil)).Elem()
		case "OptionalHeader64":
			return reflect.TypeOf((*pe.OptionalHeader64)(nil)).Elem()
		case "Reloc":
			return reflect.TypeOf((*pe.Reloc)(nil)).Elem()
		case "Section":
			return reflect.TypeOf((*pe.Section)(nil)).Elem()
		case "SectionHeader":
			return reflect.TypeOf((*pe.SectionHeader)(nil)).Elem()
		case "SectionHeader32":
			return reflect.TypeOf((*pe.SectionHeader32)(nil)).Elem()
		case "StringTable":
			return reflect.TypeOf((*pe.StringTable)(nil)).Elem()
		case "Symbol":
			return reflect.TypeOf((*pe.Symbol)(nil)).Elem()
		}
	case "debug/plan9obj":
		switch topLevelName {
		case "File":
			return reflect.TypeOf((*plan9obj.File)(nil)).Elem()
		case "FileHeader":
			return reflect.TypeOf((*plan9obj.FileHeader)(nil)).Elem()
		case "Section":
			return reflect.TypeOf((*plan9obj.Section)(nil)).Elem()
		case "SectionHeader":
			return reflect.TypeOf((*plan9obj.SectionHeader)(nil)).Elem()
		case "Sym":
			return reflect.TypeOf((*plan9obj.Sym)(nil)).Elem()
		}
	case "embed":
		switch topLevelName {
		case "FS":
			return reflect.TypeOf((*embed.FS)(nil)).Elem()
		}
	case "encoding":
		switch topLevelName {
		case "BinaryMarshaler":
			return reflect.TypeOf((*encoding.BinaryMarshaler)(nil)).Elem()
		case "BinaryUnmarshaler":
			return reflect.TypeOf((*encoding.BinaryUnmarshaler)(nil)).Elem()
		case "TextMarshaler":
			return reflect.TypeOf((*encoding.TextMarshaler)(nil)).Elem()
		case "TextUnmarshaler":
			return reflect.TypeOf((*encoding.TextUnmarshaler)(nil)).Elem()
		}
	case "encoding/ascii85":
		switch topLevelName {
		case "CorruptInputError":
			return reflect.TypeOf((*ascii85.CorruptInputError)(nil)).Elem()
		}
	case "encoding/asn1":
		switch topLevelName {
		case "BitString":
			return reflect.TypeOf((*asn1.BitString)(nil)).Elem()
		case "Enumerated":
			return reflect.TypeOf((*asn1.Enumerated)(nil)).Elem()
		case "Flag":
			return reflect.TypeOf((*asn1.Flag)(nil)).Elem()
		case "ObjectIdentifier":
			return reflect.TypeOf((*asn1.ObjectIdentifier)(nil)).Elem()
		case "RawContent":
			return reflect.TypeOf((*asn1.RawContent)(nil)).Elem()
		case "RawValue":
			return reflect.TypeOf((*asn1.RawValue)(nil)).Elem()
		case "StructuralError":
			return reflect.TypeOf((*asn1.StructuralError)(nil)).Elem()
		case "SyntaxError":
			return reflect.TypeOf((*asn1.SyntaxError)(nil)).Elem()
		}
	case "encoding/base32":
		switch topLevelName {
		case "CorruptInputError":
			return reflect.TypeOf((*base32.CorruptInputError)(nil)).Elem()
		case "Encoding":
			return reflect.TypeOf((*base32.Encoding)(nil)).Elem()
		}
	case "encoding/base64":
		switch topLevelName {
		case "CorruptInputError":
			return reflect.TypeOf((*base64.CorruptInputError)(nil)).Elem()
		case "Encoding":
			return reflect.TypeOf((*base64.Encoding)(nil)).Elem()
		}
	case "encoding/binary":
		switch topLevelName {
		case "ByteOrder":
			return reflect.TypeOf((*binary.ByteOrder)(nil)).Elem()
		}
	case "encoding/csv":
		switch topLevelName {
		case "ParseError":
			return reflect.TypeOf((*csv.ParseError)(nil)).Elem()
		case "Reader":
			return reflect.TypeOf((*csv.Reader)(nil)).Elem()
		case "Writer":
			return reflect.TypeOf((*csv.Writer)(nil)).Elem()
		}
	case "encoding/gob":
		switch topLevelName {
		case "CommonType":
			return reflect.TypeOf((*gob.CommonType)(nil)).Elem()
		case "Decoder":
			return reflect.TypeOf((*gob.Decoder)(nil)).Elem()
		case "Encoder":
			return reflect.TypeOf((*gob.Encoder)(nil)).Elem()
		case "GobDecoder":
			return reflect.TypeOf((*gob.GobDecoder)(nil)).Elem()
		case "GobEncoder":
			return reflect.TypeOf((*gob.GobEncoder)(nil)).Elem()
		}
	case "encoding/hex":
		switch topLevelName {
		case "InvalidByteError":
			return reflect.TypeOf((*hex.InvalidByteError)(nil)).Elem()
		}
	case "encoding/json":
		switch topLevelName {
		case "Decoder":
			return reflect.TypeOf((*json.Decoder)(nil)).Elem()
		case "Delim":
			return reflect.TypeOf((*json.Delim)(nil)).Elem()
		case "Encoder":
			return reflect.TypeOf((*json.Encoder)(nil)).Elem()
		case "InvalidUTF8Error":
			return reflect.TypeOf((*json.InvalidUTF8Error)(nil)).Elem()
		case "InvalidUnmarshalError":
			return reflect.TypeOf((*json.InvalidUnmarshalError)(nil)).Elem()
		case "Marshaler":
			return reflect.TypeOf((*json.Marshaler)(nil)).Elem()
		case "MarshalerError":
			return reflect.TypeOf((*json.MarshalerError)(nil)).Elem()
		case "Number":
			return reflect.TypeOf((*json.Number)(nil)).Elem()
		case "RawMessage":
			return reflect.TypeOf((*json.RawMessage)(nil)).Elem()
		case "SyntaxError":
			return reflect.TypeOf((*json.SyntaxError)(nil)).Elem()
		case "Token":
			return reflect.TypeOf((*json.Token)(nil)).Elem()
		case "UnmarshalFieldError":
			return reflect.TypeOf((*json.UnmarshalFieldError)(nil)).Elem()
		case "UnmarshalTypeError":
			return reflect.TypeOf((*json.UnmarshalTypeError)(nil)).Elem()
		case "Unmarshaler":
			return reflect.TypeOf((*json.Unmarshaler)(nil)).Elem()
		case "UnsupportedTypeError":
			return reflect.TypeOf((*json.UnsupportedTypeError)(nil)).Elem()
		case "UnsupportedValueError":
			return reflect.TypeOf((*json.UnsupportedValueError)(nil)).Elem()
		}
	case "encoding/pem":
		switch topLevelName {
		case "Block":
			return reflect.TypeOf((*pem.Block)(nil)).Elem()
		}
	case "encoding/xml":
		switch topLevelName {
		case "Attr":
			return reflect.TypeOf((*xml.Attr)(nil)).Elem()
		case "CharData":
			return reflect.TypeOf((*xml.CharData)(nil)).Elem()
		case "Comment":
			return reflect.TypeOf((*xml.Comment)(nil)).Elem()
		case "Decoder":
			return reflect.TypeOf((*xml.Decoder)(nil)).Elem()
		case "Directive":
			return reflect.TypeOf((*xml.Directive)(nil)).Elem()
		case "Encoder":
			return reflect.TypeOf((*xml.Encoder)(nil)).Elem()
		case "EndElement":
			return reflect.TypeOf((*xml.EndElement)(nil)).Elem()
		case "Marshaler":
			return reflect.TypeOf((*xml.Marshaler)(nil)).Elem()
		case "MarshalerAttr":
			return reflect.TypeOf((*xml.MarshalerAttr)(nil)).Elem()
		case "Name":
			return reflect.TypeOf((*xml.Name)(nil)).Elem()
		case "ProcInst":
			return reflect.TypeOf((*xml.ProcInst)(nil)).Elem()
		case "StartElement":
			return reflect.TypeOf((*xml.StartElement)(nil)).Elem()
		case "SyntaxError":
			return reflect.TypeOf((*xml.SyntaxError)(nil)).Elem()
		case "TagPathError":
			return reflect.TypeOf((*xml.TagPathError)(nil)).Elem()
		case "Token":
			return reflect.TypeOf((*xml.Token)(nil)).Elem()
		case "TokenReader":
			return reflect.TypeOf((*xml.TokenReader)(nil)).Elem()
		case "UnmarshalError":
			return reflect.TypeOf((*xml.UnmarshalError)(nil)).Elem()
		case "Unmarshaler":
			return reflect.TypeOf((*xml.Unmarshaler)(nil)).Elem()
		case "UnmarshalerAttr":
			return reflect.TypeOf((*xml.UnmarshalerAttr)(nil)).Elem()
		case "UnsupportedTypeError":
			return reflect.TypeOf((*xml.UnsupportedTypeError)(nil)).Elem()
		}
	case "expvar":
		switch topLevelName {
		case "Float":
			return reflect.TypeOf((*expvar.Float)(nil)).Elem()
		case "Func":
			return reflect.TypeOf((*expvar.Func)(nil)).Elem()
		case "Int":
			return reflect.TypeOf((*expvar.Int)(nil)).Elem()
		case "KeyValue":
			return reflect.TypeOf((*expvar.KeyValue)(nil)).Elem()
		case "Map":
			return reflect.TypeOf((*expvar.Map)(nil)).Elem()
		case "String":
			return reflect.TypeOf((*expvar.String)(nil)).Elem()
		case "Var":
			return reflect.TypeOf((*expvar.Var)(nil)).Elem()
		}
	case "flag":
		switch topLevelName {
		case "ErrorHandling":
			return reflect.TypeOf((*flag.ErrorHandling)(nil)).Elem()
		case "Flag":
			return reflect.TypeOf((*flag.Flag)(nil)).Elem()
		case "FlagSet":
			return reflect.TypeOf((*flag.FlagSet)(nil)).Elem()
		case "Getter":
			return reflect.TypeOf((*flag.Getter)(nil)).Elem()
		case "Value":
			return reflect.TypeOf((*flag.Value)(nil)).Elem()
		}
	case "fmt":
		switch topLevelName {
		case "Formatter":
			return reflect.TypeOf((*fmt.Formatter)(nil)).Elem()
		case "GoStringer":
			return reflect.TypeOf((*fmt.GoStringer)(nil)).Elem()
		case "ScanState":
			return reflect.TypeOf((*fmt.ScanState)(nil)).Elem()
		case "Scanner":
			return reflect.TypeOf((*fmt.Scanner)(nil)).Elem()
		case "State":
			return reflect.TypeOf((*fmt.State)(nil)).Elem()
		case "Stringer":
			return reflect.TypeOf((*fmt.Stringer)(nil)).Elem()
		}
	case "go/ast":
		switch topLevelName {
		case "ArrayType":
			return reflect.TypeOf((*ast.ArrayType)(nil)).Elem()
		case "AssignStmt":
			return reflect.TypeOf((*ast.AssignStmt)(nil)).Elem()
		case "BadDecl":
			return reflect.TypeOf((*ast.BadDecl)(nil)).Elem()
		case "BadExpr":
			return reflect.TypeOf((*ast.BadExpr)(nil)).Elem()
		case "BadStmt":
			return reflect.TypeOf((*ast.BadStmt)(nil)).Elem()
		case "BasicLit":
			return reflect.TypeOf((*ast.BasicLit)(nil)).Elem()
		case "BinaryExpr":
			return reflect.TypeOf((*ast.BinaryExpr)(nil)).Elem()
		case "BlockStmt":
			return reflect.TypeOf((*ast.BlockStmt)(nil)).Elem()
		case "BranchStmt":
			return reflect.TypeOf((*ast.BranchStmt)(nil)).Elem()
		case "CallExpr":
			return reflect.TypeOf((*ast.CallExpr)(nil)).Elem()
		case "CaseClause":
			return reflect.TypeOf((*ast.CaseClause)(nil)).Elem()
		case "ChanDir":
			return reflect.TypeOf((*ast.ChanDir)(nil)).Elem()
		case "ChanType":
			return reflect.TypeOf((*ast.ChanType)(nil)).Elem()
		case "CommClause":
			return reflect.TypeOf((*ast.CommClause)(nil)).Elem()
		case "Comment":
			return reflect.TypeOf((*ast.Comment)(nil)).Elem()
		case "CommentGroup":
			return reflect.TypeOf((*ast.CommentGroup)(nil)).Elem()
		case "CommentMap":
			return reflect.TypeOf((*ast.CommentMap)(nil)).Elem()
		case "CompositeLit":
			return reflect.TypeOf((*ast.CompositeLit)(nil)).Elem()
		case "Decl":
			return reflect.TypeOf((*ast.Decl)(nil)).Elem()
		case "DeclStmt":
			return reflect.TypeOf((*ast.DeclStmt)(nil)).Elem()
		case "DeferStmt":
			return reflect.TypeOf((*ast.DeferStmt)(nil)).Elem()
		case "Ellipsis":
			return reflect.TypeOf((*ast.Ellipsis)(nil)).Elem()
		case "EmptyStmt":
			return reflect.TypeOf((*ast.EmptyStmt)(nil)).Elem()
		case "Expr":
			return reflect.TypeOf((*ast.Expr)(nil)).Elem()
		case "ExprStmt":
			return reflect.TypeOf((*ast.ExprStmt)(nil)).Elem()
		case "Field":
			return reflect.TypeOf((*ast.Field)(nil)).Elem()
		case "FieldFilter":
			return reflect.TypeOf((*ast.FieldFilter)(nil)).Elem()
		case "FieldList":
			return reflect.TypeOf((*ast.FieldList)(nil)).Elem()
		case "File":
			return reflect.TypeOf((*ast.File)(nil)).Elem()
		case "Filter":
			return reflect.TypeOf((*ast.Filter)(nil)).Elem()
		case "ForStmt":
			return reflect.TypeOf((*ast.ForStmt)(nil)).Elem()
		case "FuncDecl":
			return reflect.TypeOf((*ast.FuncDecl)(nil)).Elem()
		case "FuncLit":
			return reflect.TypeOf((*ast.FuncLit)(nil)).Elem()
		case "FuncType":
			return reflect.TypeOf((*ast.FuncType)(nil)).Elem()
		case "GenDecl":
			return reflect.TypeOf((*ast.GenDecl)(nil)).Elem()
		case "GoStmt":
			return reflect.TypeOf((*ast.GoStmt)(nil)).Elem()
		case "Ident":
			return reflect.TypeOf((*ast.Ident)(nil)).Elem()
		case "IfStmt":
			return reflect.TypeOf((*ast.IfStmt)(nil)).Elem()
		case "ImportSpec":
			return reflect.TypeOf((*ast.ImportSpec)(nil)).Elem()
		case "Importer":
			return reflect.TypeOf((*ast.Importer)(nil)).Elem()
		case "IncDecStmt":
			return reflect.TypeOf((*ast.IncDecStmt)(nil)).Elem()
		case "IndexExpr":
			return reflect.TypeOf((*ast.IndexExpr)(nil)).Elem()
		case "IndexListExpr":
			return reflect.TypeOf((*ast.IndexListExpr)(nil)).Elem()
		case "InterfaceType":
			return reflect.TypeOf((*ast.InterfaceType)(nil)).Elem()
		case "KeyValueExpr":
			return reflect.TypeOf((*ast.KeyValueExpr)(nil)).Elem()
		case "LabeledStmt":
			return reflect.TypeOf((*ast.LabeledStmt)(nil)).Elem()
		case "MapType":
			return reflect.TypeOf((*ast.MapType)(nil)).Elem()
		case "MergeMode":
			return reflect.TypeOf((*ast.MergeMode)(nil)).Elem()
		case "Node":
			return reflect.TypeOf((*ast.Node)(nil)).Elem()
		case "ObjKind":
			return reflect.TypeOf((*ast.ObjKind)(nil)).Elem()
		case "Object":
			return reflect.TypeOf((*ast.Object)(nil)).Elem()
		case "Package":
			return reflect.TypeOf((*ast.Package)(nil)).Elem()
		case "ParenExpr":
			return reflect.TypeOf((*ast.ParenExpr)(nil)).Elem()
		case "RangeStmt":
			return reflect.TypeOf((*ast.RangeStmt)(nil)).Elem()
		case "ReturnStmt":
			return reflect.TypeOf((*ast.ReturnStmt)(nil)).Elem()
		case "Scope":
			return reflect.TypeOf((*ast.Scope)(nil)).Elem()
		case "SelectStmt":
			return reflect.TypeOf((*ast.SelectStmt)(nil)).Elem()
		case "SelectorExpr":
			return reflect.TypeOf((*ast.SelectorExpr)(nil)).Elem()
		case "SendStmt":
			return reflect.TypeOf((*ast.SendStmt)(nil)).Elem()
		case "SliceExpr":
			return reflect.TypeOf((*ast.SliceExpr)(nil)).Elem()
		case "Spec":
			return reflect.TypeOf((*ast.Spec)(nil)).Elem()
		case "StarExpr":
			return reflect.TypeOf((*ast.StarExpr)(nil)).Elem()
		case "Stmt":
			return reflect.TypeOf((*ast.Stmt)(nil)).Elem()
		case "StructType":
			return reflect.TypeOf((*ast.StructType)(nil)).Elem()
		case "SwitchStmt":
			return reflect.TypeOf((*ast.SwitchStmt)(nil)).Elem()
		case "TypeAssertExpr":
			return reflect.TypeOf((*ast.TypeAssertExpr)(nil)).Elem()
		case "TypeSpec":
			return reflect.TypeOf((*ast.TypeSpec)(nil)).Elem()
		case "TypeSwitchStmt":
			return reflect.TypeOf((*ast.TypeSwitchStmt)(nil)).Elem()
		case "UnaryExpr":
			return reflect.TypeOf((*ast.UnaryExpr)(nil)).Elem()
		case "ValueSpec":
			return reflect.TypeOf((*ast.ValueSpec)(nil)).Elem()
		case "Visitor":
			return reflect.TypeOf((*ast.Visitor)(nil)).Elem()
		}
	case "go/build":
		switch topLevelName {
		case "Context":
			return reflect.TypeOf((*build.Context)(nil)).Elem()
		case "ImportMode":
			return reflect.TypeOf((*build.ImportMode)(nil)).Elem()
		case "MultiplePackageError":
			return reflect.TypeOf((*build.MultiplePackageError)(nil)).Elem()
		case "NoGoError":
			return reflect.TypeOf((*build.NoGoError)(nil)).Elem()
		case "Package":
			return reflect.TypeOf((*build.Package)(nil)).Elem()
		}
	case "go/build/constraint":
		switch topLevelName {
		case "AndExpr":
			return reflect.TypeOf((*constraint.AndExpr)(nil)).Elem()
		case "Expr":
			return reflect.TypeOf((*constraint.Expr)(nil)).Elem()
		case "NotExpr":
			return reflect.TypeOf((*constraint.NotExpr)(nil)).Elem()
		case "OrExpr":
			return reflect.TypeOf((*constraint.OrExpr)(nil)).Elem()
		case "SyntaxError":
			return reflect.TypeOf((*constraint.SyntaxError)(nil)).Elem()
		case "TagExpr":
			return reflect.TypeOf((*constraint.TagExpr)(nil)).Elem()
		}
	case "go/constant":
		switch topLevelName {
		case "Kind":
			return reflect.TypeOf((*constant.Kind)(nil)).Elem()
		case "Value":
			return reflect.TypeOf((*constant.Value)(nil)).Elem()
		}
	case "go/doc":
		switch topLevelName {
		case "Example":
			return reflect.TypeOf((*doc.Example)(nil)).Elem()
		case "Filter":
			return reflect.TypeOf((*doc.Filter)(nil)).Elem()
		case "Func":
			return reflect.TypeOf((*doc.Func)(nil)).Elem()
		case "Mode":
			return reflect.TypeOf((*doc.Mode)(nil)).Elem()
		case "Note":
			return reflect.TypeOf((*doc.Note)(nil)).Elem()
		case "Package":
			return reflect.TypeOf((*doc.Package)(nil)).Elem()
		case "Type":
			return reflect.TypeOf((*doc.Type)(nil)).Elem()
		case "Value":
			return reflect.TypeOf((*doc.Value)(nil)).Elem()
		}
	case "go/importer":
		switch topLevelName {
		case "Lookup":
			return reflect.TypeOf((*importer.Lookup)(nil)).Elem()
		}
	case "go/parser":
		switch topLevelName {
		case "Mode":
			return reflect.TypeOf((*parser.Mode)(nil)).Elem()
		}
	case "go/printer":
		switch topLevelName {
		case "CommentedNode":
			return reflect.TypeOf((*printer.CommentedNode)(nil)).Elem()
		case "Config":
			return reflect.TypeOf((*printer.Config)(nil)).Elem()
		case "Mode":
			return reflect.TypeOf((*printer.Mode)(nil)).Elem()
		}
	case "go/scanner":
		switch topLevelName {
		case "Error":
			return reflect.TypeOf((*scanner.Error)(nil)).Elem()
		case "ErrorHandler":
			return reflect.TypeOf((*scanner.ErrorHandler)(nil)).Elem()
		case "ErrorList":
			return reflect.TypeOf((*scanner.ErrorList)(nil)).Elem()
		case "Mode":
			return reflect.TypeOf((*scanner.Mode)(nil)).Elem()
		case "Scanner":
			return reflect.TypeOf((*scanner.Scanner)(nil)).Elem()
		}
	case "go/token":
		switch topLevelName {
		case "File":
			return reflect.TypeOf((*token.File)(nil)).Elem()
		case "FileSet":
			return reflect.TypeOf((*token.FileSet)(nil)).Elem()
		case "Pos":
			return reflect.TypeOf((*token.Pos)(nil)).Elem()
		case "Position":
			return reflect.TypeOf((*token.Position)(nil)).Elem()
		case "Token":
			return reflect.TypeOf((*token.Token)(nil)).Elem()
		}
	case "go/types":
		switch topLevelName {
		case "ArgumentError":
			return reflect.TypeOf((*types.ArgumentError)(nil)).Elem()
		case "Array":
			return reflect.TypeOf((*types.Array)(nil)).Elem()
		case "Basic":
			return reflect.TypeOf((*types.Basic)(nil)).Elem()
		case "BasicInfo":
			return reflect.TypeOf((*types.BasicInfo)(nil)).Elem()
		case "BasicKind":
			return reflect.TypeOf((*types.BasicKind)(nil)).Elem()
		case "Builtin":
			return reflect.TypeOf((*types.Builtin)(nil)).Elem()
		case "Chan":
			return reflect.TypeOf((*types.Chan)(nil)).Elem()
		case "ChanDir":
			return reflect.TypeOf((*types.ChanDir)(nil)).Elem()
		case "Checker":
			return reflect.TypeOf((*types.Checker)(nil)).Elem()
		case "Config":
			return reflect.TypeOf((*types.Config)(nil)).Elem()
		case "Const":
			return reflect.TypeOf((*types.Const)(nil)).Elem()
		case "Context":
			return reflect.TypeOf((*types.Context)(nil)).Elem()
		case "Error":
			return reflect.TypeOf((*types.Error)(nil)).Elem()
		case "Func":
			return reflect.TypeOf((*types.Func)(nil)).Elem()
		case "ImportMode":
			return reflect.TypeOf((*types.ImportMode)(nil)).Elem()
		case "Importer":
			return reflect.TypeOf((*types.Importer)(nil)).Elem()
		case "ImporterFrom":
			return reflect.TypeOf((*types.ImporterFrom)(nil)).Elem()
		case "Info":
			return reflect.TypeOf((*types.Info)(nil)).Elem()
		case "Initializer":
			return reflect.TypeOf((*types.Initializer)(nil)).Elem()
		case "Instance":
			return reflect.TypeOf((*types.Instance)(nil)).Elem()
		case "Interface":
			return reflect.TypeOf((*types.Interface)(nil)).Elem()
		case "Label":
			return reflect.TypeOf((*types.Label)(nil)).Elem()
		case "Map":
			return reflect.TypeOf((*types.Map)(nil)).Elem()
		case "MethodSet":
			return reflect.TypeOf((*types.MethodSet)(nil)).Elem()
		case "Named":
			return reflect.TypeOf((*types.Named)(nil)).Elem()
		case "Nil":
			return reflect.TypeOf((*types.Nil)(nil)).Elem()
		case "Object":
			return reflect.TypeOf((*types.Object)(nil)).Elem()
		case "Package":
			return reflect.TypeOf((*types.Package)(nil)).Elem()
		case "PkgName":
			return reflect.TypeOf((*types.PkgName)(nil)).Elem()
		case "Pointer":
			return reflect.TypeOf((*types.Pointer)(nil)).Elem()
		case "Qualifier":
			return reflect.TypeOf((*types.Qualifier)(nil)).Elem()
		case "Scope":
			return reflect.TypeOf((*types.Scope)(nil)).Elem()
		case "Selection":
			return reflect.TypeOf((*types.Selection)(nil)).Elem()
		case "SelectionKind":
			return reflect.TypeOf((*types.SelectionKind)(nil)).Elem()
		case "Signature":
			return reflect.TypeOf((*types.Signature)(nil)).Elem()
		case "Sizes":
			return reflect.TypeOf((*types.Sizes)(nil)).Elem()
		case "Slice":
			return reflect.TypeOf((*types.Slice)(nil)).Elem()
		case "StdSizes":
			return reflect.TypeOf((*types.StdSizes)(nil)).Elem()
		case "Struct":
			return reflect.TypeOf((*types.Struct)(nil)).Elem()
		case "Term":
			return reflect.TypeOf((*types.Term)(nil)).Elem()
		case "Tuple":
			return reflect.TypeOf((*types.Tuple)(nil)).Elem()
		case "Type":
			return reflect.TypeOf((*types.Type)(nil)).Elem()
		case "TypeAndValue":
			return reflect.TypeOf((*types.TypeAndValue)(nil)).Elem()
		case "TypeList":
			return reflect.TypeOf((*types.TypeList)(nil)).Elem()
		case "TypeName":
			return reflect.TypeOf((*types.TypeName)(nil)).Elem()
		case "TypeParam":
			return reflect.TypeOf((*types.TypeParam)(nil)).Elem()
		case "TypeParamList":
			return reflect.TypeOf((*types.TypeParamList)(nil)).Elem()
		case "Union":
			return reflect.TypeOf((*types.Union)(nil)).Elem()
		case "Var":
			return reflect.TypeOf((*types.Var)(nil)).Elem()
		}
	case "hash":
		switch topLevelName {
		case "Hash":
			return reflect.TypeOf((*hash.Hash)(nil)).Elem()
		case "Hash32":
			return reflect.TypeOf((*hash.Hash32)(nil)).Elem()
		case "Hash64":
			return reflect.TypeOf((*hash.Hash64)(nil)).Elem()
		}
	case "hash/crc32":
		switch topLevelName {
		case "Table":
			return reflect.TypeOf((*crc32.Table)(nil)).Elem()
		}
	case "hash/crc64":
		switch topLevelName {
		case "Table":
			return reflect.TypeOf((*crc64.Table)(nil)).Elem()
		}
	case "hash/maphash":
		switch topLevelName {
		case "Hash":
			return reflect.TypeOf((*maphash.Hash)(nil)).Elem()
		case "Seed":
			return reflect.TypeOf((*maphash.Seed)(nil)).Elem()
		}
	case "html/template":
		switch topLevelName {
		case "CSS":
			return reflect.TypeOf((*template.CSS)(nil)).Elem()
		case "Error":
			return reflect.TypeOf((*template.Error)(nil)).Elem()
		case "ErrorCode":
			return reflect.TypeOf((*template.ErrorCode)(nil)).Elem()
		case "FuncMap":
			return reflect.TypeOf((*template.FuncMap)(nil)).Elem()
		case "HTML":
			return reflect.TypeOf((*template.HTML)(nil)).Elem()
		case "HTMLAttr":
			return reflect.TypeOf((*template.HTMLAttr)(nil)).Elem()
		case "JS":
			return reflect.TypeOf((*template.JS)(nil)).Elem()
		case "JSStr":
			return reflect.TypeOf((*template.JSStr)(nil)).Elem()
		case "Srcset":
			return reflect.TypeOf((*template.Srcset)(nil)).Elem()
		case "Template":
			return reflect.TypeOf((*template.Template)(nil)).Elem()
		case "URL":
			return reflect.TypeOf((*template.URL)(nil)).Elem()
		}
	case "image":
		switch topLevelName {
		case "Alpha":
			return reflect.TypeOf((*image.Alpha)(nil)).Elem()
		case "Alpha16":
			return reflect.TypeOf((*image.Alpha16)(nil)).Elem()
		case "CMYK":
			return reflect.TypeOf((*image.CMYK)(nil)).Elem()
		case "Config":
			return reflect.TypeOf((*image.Config)(nil)).Elem()
		case "Gray":
			return reflect.TypeOf((*image.Gray)(nil)).Elem()
		case "Gray16":
			return reflect.TypeOf((*image.Gray16)(nil)).Elem()
		case "Image":
			return reflect.TypeOf((*image.Image)(nil)).Elem()
		case "NRGBA":
			return reflect.TypeOf((*image.NRGBA)(nil)).Elem()
		case "NRGBA64":
			return reflect.TypeOf((*image.NRGBA64)(nil)).Elem()
		case "NYCbCrA":
			return reflect.TypeOf((*image.NYCbCrA)(nil)).Elem()
		case "Paletted":
			return reflect.TypeOf((*image.Paletted)(nil)).Elem()
		case "PalettedImage":
			return reflect.TypeOf((*image.PalettedImage)(nil)).Elem()
		case "Point":
			return reflect.TypeOf((*image.Point)(nil)).Elem()
		case "RGBA":
			return reflect.TypeOf((*image.RGBA)(nil)).Elem()
		case "RGBA64":
			return reflect.TypeOf((*image.RGBA64)(nil)).Elem()
		case "RGBA64Image":
			return reflect.TypeOf((*image.RGBA64Image)(nil)).Elem()
		case "Rectangle":
			return reflect.TypeOf((*image.Rectangle)(nil)).Elem()
		case "Uniform":
			return reflect.TypeOf((*image.Uniform)(nil)).Elem()
		case "YCbCr":
			return reflect.TypeOf((*image.YCbCr)(nil)).Elem()
		case "YCbCrSubsampleRatio":
			return reflect.TypeOf((*image.YCbCrSubsampleRatio)(nil)).Elem()
		}
	case "image/color":
		switch topLevelName {
		case "Alpha":
			return reflect.TypeOf((*color.Alpha)(nil)).Elem()
		case "Alpha16":
			return reflect.TypeOf((*color.Alpha16)(nil)).Elem()
		case "CMYK":
			return reflect.TypeOf((*color.CMYK)(nil)).Elem()
		case "Color":
			return reflect.TypeOf((*color.Color)(nil)).Elem()
		case "Gray":
			return reflect.TypeOf((*color.Gray)(nil)).Elem()
		case "Gray16":
			return reflect.TypeOf((*color.Gray16)(nil)).Elem()
		case "Model":
			return reflect.TypeOf((*color.Model)(nil)).Elem()
		case "NRGBA":
			return reflect.TypeOf((*color.NRGBA)(nil)).Elem()
		case "NRGBA64":
			return reflect.TypeOf((*color.NRGBA64)(nil)).Elem()
		case "NYCbCrA":
			return reflect.TypeOf((*color.NYCbCrA)(nil)).Elem()
		case "Palette":
			return reflect.TypeOf((*color.Palette)(nil)).Elem()
		case "RGBA":
			return reflect.TypeOf((*color.RGBA)(nil)).Elem()
		case "RGBA64":
			return reflect.TypeOf((*color.RGBA64)(nil)).Elem()
		case "YCbCr":
			return reflect.TypeOf((*color.YCbCr)(nil)).Elem()
		}
	case "image/draw":
		switch topLevelName {
		case "Drawer":
			return reflect.TypeOf((*draw.Drawer)(nil)).Elem()
		case "Image":
			return reflect.TypeOf((*draw.Image)(nil)).Elem()
		case "Op":
			return reflect.TypeOf((*draw.Op)(nil)).Elem()
		case "Quantizer":
			return reflect.TypeOf((*draw.Quantizer)(nil)).Elem()
		case "RGBA64Image":
			return reflect.TypeOf((*draw.RGBA64Image)(nil)).Elem()
		}
	case "image/gif":
		switch topLevelName {
		case "GIF":
			return reflect.TypeOf((*gif.GIF)(nil)).Elem()
		case "Options":
			return reflect.TypeOf((*gif.Options)(nil)).Elem()
		}
	case "image/jpeg":
		switch topLevelName {
		case "FormatError":
			return reflect.TypeOf((*jpeg.FormatError)(nil)).Elem()
		case "Options":
			return reflect.TypeOf((*jpeg.Options)(nil)).Elem()
		case "Reader":
			return reflect.TypeOf((*jpeg.Reader)(nil)).Elem()
		case "UnsupportedError":
			return reflect.TypeOf((*jpeg.UnsupportedError)(nil)).Elem()
		}
	case "image/png":
		switch topLevelName {
		case "CompressionLevel":
			return reflect.TypeOf((*png.CompressionLevel)(nil)).Elem()
		case "Encoder":
			return reflect.TypeOf((*png.Encoder)(nil)).Elem()
		case "EncoderBuffer":
			return reflect.TypeOf((*png.EncoderBuffer)(nil)).Elem()
		case "EncoderBufferPool":
			return reflect.TypeOf((*png.EncoderBufferPool)(nil)).Elem()
		case "FormatError":
			return reflect.TypeOf((*png.FormatError)(nil)).Elem()
		case "UnsupportedError":
			return reflect.TypeOf((*png.UnsupportedError)(nil)).Elem()
		}
	case "index/suffixarray":
		switch topLevelName {
		case "Index":
			return reflect.TypeOf((*suffixarray.Index)(nil)).Elem()
		}
	case "io":
		switch topLevelName {
		case "ByteReader":
			return reflect.TypeOf((*io.ByteReader)(nil)).Elem()
		case "ByteScanner":
			return reflect.TypeOf((*io.ByteScanner)(nil)).Elem()
		case "ByteWriter":
			return reflect.TypeOf((*io.ByteWriter)(nil)).Elem()
		case "Closer":
			return reflect.TypeOf((*io.Closer)(nil)).Elem()
		case "LimitedReader":
			return reflect.TypeOf((*io.LimitedReader)(nil)).Elem()
		case "PipeReader":
			return reflect.TypeOf((*io.PipeReader)(nil)).Elem()
		case "PipeWriter":
			return reflect.TypeOf((*io.PipeWriter)(nil)).Elem()
		case "ReadCloser":
			return reflect.TypeOf((*io.ReadCloser)(nil)).Elem()
		case "ReadSeekCloser":
			return reflect.TypeOf((*io.ReadSeekCloser)(nil)).Elem()
		case "ReadSeeker":
			return reflect.TypeOf((*io.ReadSeeker)(nil)).Elem()
		case "ReadWriteCloser":
			return reflect.TypeOf((*io.ReadWriteCloser)(nil)).Elem()
		case "ReadWriteSeeker":
			return reflect.TypeOf((*io.ReadWriteSeeker)(nil)).Elem()
		case "ReadWriter":
			return reflect.TypeOf((*io.ReadWriter)(nil)).Elem()
		case "Reader":
			return reflect.TypeOf((*io.Reader)(nil)).Elem()
		case "ReaderAt":
			return reflect.TypeOf((*io.ReaderAt)(nil)).Elem()
		case "ReaderFrom":
			return reflect.TypeOf((*io.ReaderFrom)(nil)).Elem()
		case "RuneReader":
			return reflect.TypeOf((*io.RuneReader)(nil)).Elem()
		case "RuneScanner":
			return reflect.TypeOf((*io.RuneScanner)(nil)).Elem()
		case "SectionReader":
			return reflect.TypeOf((*io.SectionReader)(nil)).Elem()
		case "Seeker":
			return reflect.TypeOf((*io.Seeker)(nil)).Elem()
		case "StringWriter":
			return reflect.TypeOf((*io.StringWriter)(nil)).Elem()
		case "WriteCloser":
			return reflect.TypeOf((*io.WriteCloser)(nil)).Elem()
		case "WriteSeeker":
			return reflect.TypeOf((*io.WriteSeeker)(nil)).Elem()
		case "Writer":
			return reflect.TypeOf((*io.Writer)(nil)).Elem()
		case "WriterAt":
			return reflect.TypeOf((*io.WriterAt)(nil)).Elem()
		case "WriterTo":
			return reflect.TypeOf((*io.WriterTo)(nil)).Elem()
		}
	case "io/fs":
		switch topLevelName {
		case "DirEntry":
			return reflect.TypeOf((*fs.DirEntry)(nil)).Elem()
		case "FS":
			return reflect.TypeOf((*fs.FS)(nil)).Elem()
		case "File":
			return reflect.TypeOf((*fs.File)(nil)).Elem()
		case "FileInfo":
			return reflect.TypeOf((*fs.FileInfo)(nil)).Elem()
		case "FileMode":
			return reflect.TypeOf((*fs.FileMode)(nil)).Elem()
		case "GlobFS":
			return reflect.TypeOf((*fs.GlobFS)(nil)).Elem()
		case "PathError":
			return reflect.TypeOf((*fs.PathError)(nil)).Elem()
		case "ReadDirFS":
			return reflect.TypeOf((*fs.ReadDirFS)(nil)).Elem()
		case "ReadDirFile":
			return reflect.TypeOf((*fs.ReadDirFile)(nil)).Elem()
		case "ReadFileFS":
			return reflect.TypeOf((*fs.ReadFileFS)(nil)).Elem()
		case "StatFS":
			return reflect.TypeOf((*fs.StatFS)(nil)).Elem()
		case "SubFS":
			return reflect.TypeOf((*fs.SubFS)(nil)).Elem()
		case "WalkDirFunc":
			return reflect.TypeOf((*fs.WalkDirFunc)(nil)).Elem()
		}
	case "log":
		switch topLevelName {
		case "Logger":
			return reflect.TypeOf((*log.Logger)(nil)).Elem()
		}
	case "math/big":
		switch topLevelName {
		case "Accuracy":
			return reflect.TypeOf((*big.Accuracy)(nil)).Elem()
		case "ErrNaN":
			return reflect.TypeOf((*big.ErrNaN)(nil)).Elem()
		case "Float":
			return reflect.TypeOf((*big.Float)(nil)).Elem()
		case "Int":
			return reflect.TypeOf((*big.Int)(nil)).Elem()
		case "Rat":
			return reflect.TypeOf((*big.Rat)(nil)).Elem()
		case "RoundingMode":
			return reflect.TypeOf((*big.RoundingMode)(nil)).Elem()
		case "Word":
			return reflect.TypeOf((*big.Word)(nil)).Elem()
		}
	case "math/rand":
		switch topLevelName {
		case "Rand":
			return reflect.TypeOf((*rand1.Rand)(nil)).Elem()
		case "Source":
			return reflect.TypeOf((*rand1.Source)(nil)).Elem()
		case "Source64":
			return reflect.TypeOf((*rand1.Source64)(nil)).Elem()
		case "Zipf":
			return reflect.TypeOf((*rand1.Zipf)(nil)).Elem()
		}
	case "mime":
		switch topLevelName {
		case "WordDecoder":
			return reflect.TypeOf((*mime.WordDecoder)(nil)).Elem()
		case "WordEncoder":
			return reflect.TypeOf((*mime.WordEncoder)(nil)).Elem()
		}
	case "mime/multipart":
		switch topLevelName {
		case "File":
			return reflect.TypeOf((*multipart.File)(nil)).Elem()
		case "FileHeader":
			return reflect.TypeOf((*multipart.FileHeader)(nil)).Elem()
		case "Form":
			return reflect.TypeOf((*multipart.Form)(nil)).Elem()
		case "Part":
			return reflect.TypeOf((*multipart.Part)(nil)).Elem()
		case "Reader":
			return reflect.TypeOf((*multipart.Reader)(nil)).Elem()
		case "Writer":
			return reflect.TypeOf((*multipart.Writer)(nil)).Elem()
		}
	case "mime/quotedprintable":
		switch topLevelName {
		case "Reader":
			return reflect.TypeOf((*quotedprintable.Reader)(nil)).Elem()
		case "Writer":
			return reflect.TypeOf((*quotedprintable.Writer)(nil)).Elem()
		}
	case "net":
		switch topLevelName {
		case "Addr":
			return reflect.TypeOf((*net.Addr)(nil)).Elem()
		case "AddrError":
			return reflect.TypeOf((*net.AddrError)(nil)).Elem()
		case "Buffers":
			return reflect.TypeOf((*net.Buffers)(nil)).Elem()
		case "Conn":
			return reflect.TypeOf((*net.Conn)(nil)).Elem()
		case "DNSConfigError":
			return reflect.TypeOf((*net.DNSConfigError)(nil)).Elem()
		case "DNSError":
			return reflect.TypeOf((*net.DNSError)(nil)).Elem()
		case "Dialer":
			return reflect.TypeOf((*net.Dialer)(nil)).Elem()
		case "Error":
			return reflect.TypeOf((*net.Error)(nil)).Elem()
		case "Flags":
			return reflect.TypeOf((*net.Flags)(nil)).Elem()
		case "HardwareAddr":
			return reflect.TypeOf((*net.HardwareAddr)(nil)).Elem()
		case "IP":
			return reflect.TypeOf((*net.IP)(nil)).Elem()
		case "IPAddr":
			return reflect.TypeOf((*net.IPAddr)(nil)).Elem()
		case "IPConn":
			return reflect.TypeOf((*net.IPConn)(nil)).Elem()
		case "IPMask":
			return reflect.TypeOf((*net.IPMask)(nil)).Elem()
		case "IPNet":
			return reflect.TypeOf((*net.IPNet)(nil)).Elem()
		case "Interface":
			return reflect.TypeOf((*net.Interface)(nil)).Elem()
		case "InvalidAddrError":
			return reflect.TypeOf((*net.InvalidAddrError)(nil)).Elem()
		case "ListenConfig":
			return reflect.TypeOf((*net.ListenConfig)(nil)).Elem()
		case "Listener":
			return reflect.TypeOf((*net.Listener)(nil)).Elem()
		case "MX":
			return reflect.TypeOf((*net.MX)(nil)).Elem()
		case "NS":
			return reflect.TypeOf((*net.NS)(nil)).Elem()
		case "OpError":
			return reflect.TypeOf((*net.OpError)(nil)).Elem()
		case "PacketConn":
			return reflect.TypeOf((*net.PacketConn)(nil)).Elem()
		case "ParseError":
			return reflect.TypeOf((*net.ParseError)(nil)).Elem()
		case "Resolver":
			return reflect.TypeOf((*net.Resolver)(nil)).Elem()
		case "SRV":
			return reflect.TypeOf((*net.SRV)(nil)).Elem()
		case "TCPAddr":
			return reflect.TypeOf((*net.TCPAddr)(nil)).Elem()
		case "TCPConn":
			return reflect.TypeOf((*net.TCPConn)(nil)).Elem()
		case "TCPListener":
			return reflect.TypeOf((*net.TCPListener)(nil)).Elem()
		case "UDPAddr":
			return reflect.TypeOf((*net.UDPAddr)(nil)).Elem()
		case "UDPConn":
			return reflect.TypeOf((*net.UDPConn)(nil)).Elem()
		case "UnixAddr":
			return reflect.TypeOf((*net.UnixAddr)(nil)).Elem()
		case "UnixConn":
			return reflect.TypeOf((*net.UnixConn)(nil)).Elem()
		case "UnixListener":
			return reflect.TypeOf((*net.UnixListener)(nil)).Elem()
		case "UnknownNetworkError":
			return reflect.TypeOf((*net.UnknownNetworkError)(nil)).Elem()
		}
	case "net/http":
		switch topLevelName {
		case "Client":
			return reflect.TypeOf((*http.Client)(nil)).Elem()
		case "CloseNotifier":
			return reflect.TypeOf((*http.CloseNotifier)(nil)).Elem()
		case "ConnState":
			return reflect.TypeOf((*http.ConnState)(nil)).Elem()
		case "Cookie":
			return reflect.TypeOf((*http.Cookie)(nil)).Elem()
		case "CookieJar":
			return reflect.TypeOf((*http.CookieJar)(nil)).Elem()
		case "Dir":
			return reflect.TypeOf((*http.Dir)(nil)).Elem()
		case "File":
			return reflect.TypeOf((*http.File)(nil)).Elem()
		case "FileSystem":
			return reflect.TypeOf((*http.FileSystem)(nil)).Elem()
		case "Flusher":
			return reflect.TypeOf((*http.Flusher)(nil)).Elem()
		case "Handler":
			return reflect.TypeOf((*http.Handler)(nil)).Elem()
		case "HandlerFunc":
			return reflect.TypeOf((*http.HandlerFunc)(nil)).Elem()
		case "Header":
			return reflect.TypeOf((*http.Header)(nil)).Elem()
		case "Hijacker":
			return reflect.TypeOf((*http.Hijacker)(nil)).Elem()
		case "ProtocolError":
			return reflect.TypeOf((*http.ProtocolError)(nil)).Elem()
		case "PushOptions":
			return reflect.TypeOf((*http.PushOptions)(nil)).Elem()
		case "Pusher":
			return reflect.TypeOf((*http.Pusher)(nil)).Elem()
		case "Request":
			return reflect.TypeOf((*http.Request)(nil)).Elem()
		case "Response":
			return reflect.TypeOf((*http.Response)(nil)).Elem()
		case "ResponseWriter":
			return reflect.TypeOf((*http.ResponseWriter)(nil)).Elem()
		case "RoundTripper":
			return reflect.TypeOf((*http.RoundTripper)(nil)).Elem()
		case "SameSite":
			return reflect.TypeOf((*http.SameSite)(nil)).Elem()
		case "ServeMux":
			return reflect.TypeOf((*http.ServeMux)(nil)).Elem()
		case "Server":
			return reflect.TypeOf((*http.Server)(nil)).Elem()
		case "Transport":
			return reflect.TypeOf((*http.Transport)(nil)).Elem()
		}
	case "net/http/cgi":
		switch topLevelName {
		case "Handler":
			return reflect.TypeOf((*cgi.Handler)(nil)).Elem()
		}
	case "net/http/cookiejar":
		switch topLevelName {
		case "Jar":
			return reflect.TypeOf((*cookiejar.Jar)(nil)).Elem()
		case "Options":
			return reflect.TypeOf((*cookiejar.Options)(nil)).Elem()
		case "PublicSuffixList":
			return reflect.TypeOf((*cookiejar.PublicSuffixList)(nil)).Elem()
		}
	case "net/http/httptest":
		switch topLevelName {
		case "ResponseRecorder":
			return reflect.TypeOf((*httptest.ResponseRecorder)(nil)).Elem()
		case "Server":
			return reflect.TypeOf((*httptest.Server)(nil)).Elem()
		}
	case "net/http/httptrace":
		switch topLevelName {
		case "ClientTrace":
			return reflect.TypeOf((*httptrace.ClientTrace)(nil)).Elem()
		case "DNSDoneInfo":
			return reflect.TypeOf((*httptrace.DNSDoneInfo)(nil)).Elem()
		case "DNSStartInfo":
			return reflect.TypeOf((*httptrace.DNSStartInfo)(nil)).Elem()
		case "GotConnInfo":
			return reflect.TypeOf((*httptrace.GotConnInfo)(nil)).Elem()
		case "WroteRequestInfo":
			return reflect.TypeOf((*httptrace.WroteRequestInfo)(nil)).Elem()
		}
	case "net/http/httputil":
		switch topLevelName {
		case "BufferPool":
			return reflect.TypeOf((*httputil.BufferPool)(nil)).Elem()
		case "ClientConn":
			return reflect.TypeOf((*httputil.ClientConn)(nil)).Elem()
		case "ReverseProxy":
			return reflect.TypeOf((*httputil.ReverseProxy)(nil)).Elem()
		case "ServerConn":
			return reflect.TypeOf((*httputil.ServerConn)(nil)).Elem()
		}
	case "net/mail":
		switch topLevelName {
		case "Address":
			return reflect.TypeOf((*mail.Address)(nil)).Elem()
		case "AddressParser":
			return reflect.TypeOf((*mail.AddressParser)(nil)).Elem()
		case "Header":
			return reflect.TypeOf((*mail.Header)(nil)).Elem()
		case "Message":
			return reflect.TypeOf((*mail.Message)(nil)).Elem()
		}
	case "net/netip":
		switch topLevelName {
		case "Addr":
			return reflect.TypeOf((*netip.Addr)(nil)).Elem()
		case "AddrPort":
			return reflect.TypeOf((*netip.AddrPort)(nil)).Elem()
		case "Prefix":
			return reflect.TypeOf((*netip.Prefix)(nil)).Elem()
		}
	case "net/rpc":
		switch topLevelName {
		case "Call":
			return reflect.TypeOf((*rpc.Call)(nil)).Elem()
		case "Client":
			return reflect.TypeOf((*rpc.Client)(nil)).Elem()
		case "ClientCodec":
			return reflect.TypeOf((*rpc.ClientCodec)(nil)).Elem()
		case "Request":
			return reflect.TypeOf((*rpc.Request)(nil)).Elem()
		case "Response":
			return reflect.TypeOf((*rpc.Response)(nil)).Elem()
		case "Server":
			return reflect.TypeOf((*rpc.Server)(nil)).Elem()
		case "ServerCodec":
			return reflect.TypeOf((*rpc.ServerCodec)(nil)).Elem()
		case "ServerError":
			return reflect.TypeOf((*rpc.ServerError)(nil)).Elem()
		}
	case "net/smtp":
		switch topLevelName {
		case "Auth":
			return reflect.TypeOf((*smtp.Auth)(nil)).Elem()
		case "Client":
			return reflect.TypeOf((*smtp.Client)(nil)).Elem()
		case "ServerInfo":
			return reflect.TypeOf((*smtp.ServerInfo)(nil)).Elem()
		}
	case "net/textproto":
		switch topLevelName {
		case "Conn":
			return reflect.TypeOf((*textproto.Conn)(nil)).Elem()
		case "Error":
			return reflect.TypeOf((*textproto.Error)(nil)).Elem()
		case "MIMEHeader":
			return reflect.TypeOf((*textproto.MIMEHeader)(nil)).Elem()
		case "Pipeline":
			return reflect.TypeOf((*textproto.Pipeline)(nil)).Elem()
		case "ProtocolError":
			return reflect.TypeOf((*textproto.ProtocolError)(nil)).Elem()
		case "Reader":
			return reflect.TypeOf((*textproto.Reader)(nil)).Elem()
		case "Writer":
			return reflect.TypeOf((*textproto.Writer)(nil)).Elem()
		}
	case "net/url":
		switch topLevelName {
		case "Error":
			return reflect.TypeOf((*url.Error)(nil)).Elem()
		case "EscapeError":
			return reflect.TypeOf((*url.EscapeError)(nil)).Elem()
		case "InvalidHostError":
			return reflect.TypeOf((*url.InvalidHostError)(nil)).Elem()
		case "URL":
			return reflect.TypeOf((*url.URL)(nil)).Elem()
		case "Userinfo":
			return reflect.TypeOf((*url.Userinfo)(nil)).Elem()
		case "Values":
			return reflect.TypeOf((*url.Values)(nil)).Elem()
		}
	case "os":
		switch topLevelName {
		case "DirEntry":
			return reflect.TypeOf((*os.DirEntry)(nil)).Elem()
		case "File":
			return reflect.TypeOf((*os.File)(nil)).Elem()
		case "FileInfo":
			return reflect.TypeOf((*os.FileInfo)(nil)).Elem()
		case "FileMode":
			return reflect.TypeOf((*os.FileMode)(nil)).Elem()
		case "LinkError":
			return reflect.TypeOf((*os.LinkError)(nil)).Elem()
		case "PathError":
			return reflect.TypeOf((*os.PathError)(nil)).Elem()
		case "ProcAttr":
			return reflect.TypeOf((*os.ProcAttr)(nil)).Elem()
		case "Process":
			return reflect.TypeOf((*os.Process)(nil)).Elem()
		case "ProcessState":
			return reflect.TypeOf((*os.ProcessState)(nil)).Elem()
		case "Signal":
			return reflect.TypeOf((*os.Signal)(nil)).Elem()
		case "SyscallError":
			return reflect.TypeOf((*os.SyscallError)(nil)).Elem()
		}
	case "os/exec":
		switch topLevelName {
		case "Cmd":
			return reflect.TypeOf((*exec.Cmd)(nil)).Elem()
		case "Error":
			return reflect.TypeOf((*exec.Error)(nil)).Elem()
		case "ExitError":
			return reflect.TypeOf((*exec.ExitError)(nil)).Elem()
		}
	case "os/user":
		switch topLevelName {
		case "Group":
			return reflect.TypeOf((*user.Group)(nil)).Elem()
		case "UnknownGroupError":
			return reflect.TypeOf((*user.UnknownGroupError)(nil)).Elem()
		case "UnknownGroupIdError":
			return reflect.TypeOf((*user.UnknownGroupIdError)(nil)).Elem()
		case "UnknownUserError":
			return reflect.TypeOf((*user.UnknownUserError)(nil)).Elem()
		case "UnknownUserIdError":
			return reflect.TypeOf((*user.UnknownUserIdError)(nil)).Elem()
		case "User":
			return reflect.TypeOf((*user.User)(nil)).Elem()
		}
	case "path/filepath":
		switch topLevelName {
		case "WalkFunc":
			return reflect.TypeOf((*filepath.WalkFunc)(nil)).Elem()
		}
	case "plugin":
		switch topLevelName {
		case "Plugin":
			return reflect.TypeOf((*plugin.Plugin)(nil)).Elem()
		case "Symbol":
			return reflect.TypeOf((*plugin.Symbol)(nil)).Elem()
		}
	case "reflect":
		switch topLevelName {
		case "ChanDir":
			return reflect.TypeOf((*reflect.ChanDir)(nil)).Elem()
		case "Kind":
			return reflect.TypeOf((*reflect.Kind)(nil)).Elem()
		case "MapIter":
			return reflect.TypeOf((*reflect.MapIter)(nil)).Elem()
		case "Method":
			return reflect.TypeOf((*reflect.Method)(nil)).Elem()
		case "SelectCase":
			return reflect.TypeOf((*reflect.SelectCase)(nil)).Elem()
		case "SelectDir":
			return reflect.TypeOf((*reflect.SelectDir)(nil)).Elem()
		case "SliceHeader":
			return reflect.TypeOf((*reflect.SliceHeader)(nil)).Elem()
		case "StringHeader":
			return reflect.TypeOf((*reflect.StringHeader)(nil)).Elem()
		case "StructField":
			return reflect.TypeOf((*reflect.StructField)(nil)).Elem()
		case "StructTag":
			return reflect.TypeOf((*reflect.StructTag)(nil)).Elem()
		case "Type":
			return reflect.TypeOf((*reflect.Type)(nil)).Elem()
		case "Value":
			return reflect.TypeOf((*reflect.Value)(nil)).Elem()
		case "ValueError":
			return reflect.TypeOf((*reflect.ValueError)(nil)).Elem()
		}
	case "regexp":
		switch topLevelName {
		case "Regexp":
			return reflect.TypeOf((*regexp.Regexp)(nil)).Elem()
		}
	case "regexp/syntax":
		switch topLevelName {
		case "EmptyOp":
			return reflect.TypeOf((*syntax.EmptyOp)(nil)).Elem()
		case "Error":
			return reflect.TypeOf((*syntax.Error)(nil)).Elem()
		case "ErrorCode":
			return reflect.TypeOf((*syntax.ErrorCode)(nil)).Elem()
		case "Flags":
			return reflect.TypeOf((*syntax.Flags)(nil)).Elem()
		case "Inst":
			return reflect.TypeOf((*syntax.Inst)(nil)).Elem()
		case "InstOp":
			return reflect.TypeOf((*syntax.InstOp)(nil)).Elem()
		case "Op":
			return reflect.TypeOf((*syntax.Op)(nil)).Elem()
		case "Prog":
			return reflect.TypeOf((*syntax.Prog)(nil)).Elem()
		case "Regexp":
			return reflect.TypeOf((*syntax.Regexp)(nil)).Elem()
		}
	case "runtime":
		switch topLevelName {
		case "BlockProfileRecord":
			return reflect.TypeOf((*runtime.BlockProfileRecord)(nil)).Elem()
		case "Error":
			return reflect.TypeOf((*runtime.Error)(nil)).Elem()
		case "Frame":
			return reflect.TypeOf((*runtime.Frame)(nil)).Elem()
		case "Frames":
			return reflect.TypeOf((*runtime.Frames)(nil)).Elem()
		case "Func":
			return reflect.TypeOf((*runtime.Func)(nil)).Elem()
		case "MemProfileRecord":
			return reflect.TypeOf((*runtime.MemProfileRecord)(nil)).Elem()
		case "MemStats":
			return reflect.TypeOf((*runtime.MemStats)(nil)).Elem()
		case "StackRecord":
			return reflect.TypeOf((*runtime.StackRecord)(nil)).Elem()
		case "TypeAssertionError":
			return reflect.TypeOf((*runtime.TypeAssertionError)(nil)).Elem()
		}
	case "runtime/debug":
		switch topLevelName {
		case "BuildInfo":
			return reflect.TypeOf((*debug.BuildInfo)(nil)).Elem()
		case "BuildSetting":
			return reflect.TypeOf((*debug.BuildSetting)(nil)).Elem()
		case "GCStats":
			return reflect.TypeOf((*debug.GCStats)(nil)).Elem()
		case "Module":
			return reflect.TypeOf((*debug.Module)(nil)).Elem()
		}
	case "runtime/metrics":
		switch topLevelName {
		case "Description":
			return reflect.TypeOf((*metrics.Description)(nil)).Elem()
		case "Float64Histogram":
			return reflect.TypeOf((*metrics.Float64Histogram)(nil)).Elem()
		case "Sample":
			return reflect.TypeOf((*metrics.Sample)(nil)).Elem()
		case "Value":
			return reflect.TypeOf((*metrics.Value)(nil)).Elem()
		case "ValueKind":
			return reflect.TypeOf((*metrics.ValueKind)(nil)).Elem()
		}
	case "runtime/pprof":
		switch topLevelName {
		case "LabelSet":
			return reflect.TypeOf((*pprof1.LabelSet)(nil)).Elem()
		case "Profile":
			return reflect.TypeOf((*pprof1.Profile)(nil)).Elem()
		}
	case "runtime/trace":
		switch topLevelName {
		case "Region":
			return reflect.TypeOf((*trace.Region)(nil)).Elem()
		case "Task":
			return reflect.TypeOf((*trace.Task)(nil)).Elem()
		}
	case "sort":
		switch topLevelName {
		case "Float64Slice":
			return reflect.TypeOf((*sort.Float64Slice)(nil)).Elem()
		case "IntSlice":
			return reflect.TypeOf((*sort.IntSlice)(nil)).Elem()
		case "Interface":
			return reflect.TypeOf((*sort.Interface)(nil)).Elem()
		case "StringSlice":
			return reflect.TypeOf((*sort.StringSlice)(nil)).Elem()
		}
	case "strconv":
		switch topLevelName {
		case "NumError":
			return reflect.TypeOf((*strconv.NumError)(nil)).Elem()
		}
	case "strings":
		switch topLevelName {
		case "Builder":
			return reflect.TypeOf((*strings.Builder)(nil)).Elem()
		case "Reader":
			return reflect.TypeOf((*strings.Reader)(nil)).Elem()
		case "Replacer":
			return reflect.TypeOf((*strings.Replacer)(nil)).Elem()
		}
	case "sync":
		switch topLevelName {
		case "Cond":
			return reflect.TypeOf((*sync.Cond)(nil)).Elem()
		case "Locker":
			return reflect.TypeOf((*sync.Locker)(nil)).Elem()
		case "Map":
			return reflect.TypeOf((*sync.Map)(nil)).Elem()
		case "Mutex":
			return reflect.TypeOf((*sync.Mutex)(nil)).Elem()
		case "Once":
			return reflect.TypeOf((*sync.Once)(nil)).Elem()
		case "Pool":
			return reflect.TypeOf((*sync.Pool)(nil)).Elem()
		case "RWMutex":
			return reflect.TypeOf((*sync.RWMutex)(nil)).Elem()
		case "WaitGroup":
			return reflect.TypeOf((*sync.WaitGroup)(nil)).Elem()
		}
	case "sync/atomic":
		switch topLevelName {
		case "Value":
			return reflect.TypeOf((*atomic.Value)(nil)).Elem()
		}
	case "testing":
		switch topLevelName {
		case "B":
			return reflect.TypeOf((*testing.B)(nil)).Elem()
		case "BenchmarkResult":
			return reflect.TypeOf((*testing.BenchmarkResult)(nil)).Elem()
		case "Cover":
			return reflect.TypeOf((*testing.Cover)(nil)).Elem()
		case "CoverBlock":
			return reflect.TypeOf((*testing.CoverBlock)(nil)).Elem()
		case "F":
			return reflect.TypeOf((*testing.F)(nil)).Elem()
		case "InternalBenchmark":
			return reflect.TypeOf((*testing.InternalBenchmark)(nil)).Elem()
		case "InternalExample":
			return reflect.TypeOf((*testing.InternalExample)(nil)).Elem()
		case "InternalFuzzTarget":
			return reflect.TypeOf((*testing.InternalFuzzTarget)(nil)).Elem()
		case "InternalTest":
			return reflect.TypeOf((*testing.InternalTest)(nil)).Elem()
		case "M":
			return reflect.TypeOf((*testing.M)(nil)).Elem()
		case "PB":
			return reflect.TypeOf((*testing.PB)(nil)).Elem()
		case "T":
			return reflect.TypeOf((*testing.T)(nil)).Elem()
		case "TB":
			return reflect.TypeOf((*testing.TB)(nil)).Elem()
		}
	case "testing/fstest":
		switch topLevelName {
		case "MapFS":
			return reflect.TypeOf((*fstest.MapFS)(nil)).Elem()
		case "MapFile":
			return reflect.TypeOf((*fstest.MapFile)(nil)).Elem()
		}
	case "testing/quick":
		switch topLevelName {
		case "CheckEqualError":
			return reflect.TypeOf((*quick.CheckEqualError)(nil)).Elem()
		case "CheckError":
			return reflect.TypeOf((*quick.CheckError)(nil)).Elem()
		case "Config":
			return reflect.TypeOf((*quick.Config)(nil)).Elem()
		case "Generator":
			return reflect.TypeOf((*quick.Generator)(nil)).Elem()
		case "SetupError":
			return reflect.TypeOf((*quick.SetupError)(nil)).Elem()
		}
	case "text/scanner":
		switch topLevelName {
		case "Position":
			return reflect.TypeOf((*scanner1.Position)(nil)).Elem()
		case "Scanner":
			return reflect.TypeOf((*scanner1.Scanner)(nil)).Elem()
		}
	case "text/tabwriter":
		switch topLevelName {
		case "Writer":
			return reflect.TypeOf((*tabwriter.Writer)(nil)).Elem()
		}
	case "text/template":
		switch topLevelName {
		case "ExecError":
			return reflect.TypeOf((*template1.ExecError)(nil)).Elem()
		case "FuncMap":
			return reflect.TypeOf((*template1.FuncMap)(nil)).Elem()
		case "Template":
			return reflect.TypeOf((*template1.Template)(nil)).Elem()
		}
	case "text/template/parse":
		switch topLevelName {
		case "ActionNode":
			return reflect.TypeOf((*parse.ActionNode)(nil)).Elem()
		case "BoolNode":
			return reflect.TypeOf((*parse.BoolNode)(nil)).Elem()
		case "BranchNode":
			return reflect.TypeOf((*parse.BranchNode)(nil)).Elem()
		case "BreakNode":
			return reflect.TypeOf((*parse.BreakNode)(nil)).Elem()
		case "ChainNode":
			return reflect.TypeOf((*parse.ChainNode)(nil)).Elem()
		case "CommandNode":
			return reflect.TypeOf((*parse.CommandNode)(nil)).Elem()
		case "CommentNode":
			return reflect.TypeOf((*parse.CommentNode)(nil)).Elem()
		case "ContinueNode":
			return reflect.TypeOf((*parse.ContinueNode)(nil)).Elem()
		case "DotNode":
			return reflect.TypeOf((*parse.DotNode)(nil)).Elem()
		case "FieldNode":
			return reflect.TypeOf((*parse.FieldNode)(nil)).Elem()
		case "IdentifierNode":
			return reflect.TypeOf((*parse.IdentifierNode)(nil)).Elem()
		case "IfNode":
			return reflect.TypeOf((*parse.IfNode)(nil)).Elem()
		case "ListNode":
			return reflect.TypeOf((*parse.ListNode)(nil)).Elem()
		case "Mode":
			return reflect.TypeOf((*parse.Mode)(nil)).Elem()
		case "NilNode":
			return reflect.TypeOf((*parse.NilNode)(nil)).Elem()
		case "Node":
			return reflect.TypeOf((*parse.Node)(nil)).Elem()
		case "NodeType":
			return reflect.TypeOf((*parse.NodeType)(nil)).Elem()
		case "NumberNode":
			return reflect.TypeOf((*parse.NumberNode)(nil)).Elem()
		case "PipeNode":
			return reflect.TypeOf((*parse.PipeNode)(nil)).Elem()
		case "Pos":
			return reflect.TypeOf((*parse.Pos)(nil)).Elem()
		case "RangeNode":
			return reflect.TypeOf((*parse.RangeNode)(nil)).Elem()
		case "StringNode":
			return reflect.TypeOf((*parse.StringNode)(nil)).Elem()
		case "TemplateNode":
			return reflect.TypeOf((*parse.TemplateNode)(nil)).Elem()
		case "TextNode":
			return reflect.TypeOf((*parse.TextNode)(nil)).Elem()
		case "Tree":
			return reflect.TypeOf((*parse.Tree)(nil)).Elem()
		case "VariableNode":
			return reflect.TypeOf((*parse.VariableNode)(nil)).Elem()
		case "WithNode":
			return reflect.TypeOf((*parse.WithNode)(nil)).Elem()
		}
	case "time":
		switch topLevelName {
		case "Duration":
			return reflect.TypeOf((*time.Duration)(nil)).Elem()
		case "Location":
			return reflect.TypeOf((*time.Location)(nil)).Elem()
		case "Month":
			return reflect.TypeOf((*time.Month)(nil)).Elem()
		case "ParseError":
			return reflect.TypeOf((*time.ParseError)(nil)).Elem()
		case "Ticker":
			return reflect.TypeOf((*time.Ticker)(nil)).Elem()
		case "Time":
			return reflect.TypeOf((*time.Time)(nil)).Elem()
		case "Timer":
			return reflect.TypeOf((*time.Timer)(nil)).Elem()
		case "Weekday":
			return reflect.TypeOf((*time.Weekday)(nil)).Elem()
		}
	case "unicode":
		switch topLevelName {
		case "CaseRange":
			return reflect.TypeOf((*unicode.CaseRange)(nil)).Elem()
		case "Range16":
			return reflect.TypeOf((*unicode.Range16)(nil)).Elem()
		case "Range32":
			return reflect.TypeOf((*unicode.Range32)(nil)).Elem()
		case "RangeTable":
			return reflect.TypeOf((*unicode.RangeTable)(nil)).Elem()
		case "SpecialCase":
			return reflect.TypeOf((*unicode.SpecialCase)(nil)).Elem()
		}
	}
	return nil
}

func (reflector) ReflectValue(pkgName, topLevelName string) reflect.Value {
	switch pkgName {
	case "archive/tar":
		switch topLevelName {
		case "ErrFieldTooLong":
			return reflect.ValueOf(&tar.ErrFieldTooLong)
		case "ErrHeader":
			return reflect.ValueOf(&tar.ErrHeader)
		case "ErrWriteAfterClose":
			return reflect.ValueOf(&tar.ErrWriteAfterClose)
		case "ErrWriteTooLong":
			return reflect.ValueOf(&tar.ErrWriteTooLong)
		case "FileInfoHeader":
			return reflect.ValueOf(tar.FileInfoHeader)
		case "NewReader":
			return reflect.ValueOf(tar.NewReader)
		case "NewWriter":
			return reflect.ValueOf(tar.NewWriter)
		}
	case "archive/zip":
		switch topLevelName {
		case "ErrAlgorithm":
			return reflect.ValueOf(&zip.ErrAlgorithm)
		case "ErrChecksum":
			return reflect.ValueOf(&zip.ErrChecksum)
		case "ErrFormat":
			return reflect.ValueOf(&zip.ErrFormat)
		case "FileInfoHeader":
			return reflect.ValueOf(zip.FileInfoHeader)
		case "NewReader":
			return reflect.ValueOf(zip.NewReader)
		case "NewWriter":
			return reflect.ValueOf(zip.NewWriter)
		case "OpenReader":
			return reflect.ValueOf(zip.OpenReader)
		case "RegisterCompressor":
			return reflect.ValueOf(zip.RegisterCompressor)
		case "RegisterDecompressor":
			return reflect.ValueOf(zip.RegisterDecompressor)
		}
	case "bufio":
		switch topLevelName {
		case "ErrAdvanceTooFar":
			return reflect.ValueOf(&bufio.ErrAdvanceTooFar)
		case "ErrBadReadCount":
			return reflect.ValueOf(&bufio.ErrBadReadCount)
		case "ErrBufferFull":
			return reflect.ValueOf(&bufio.ErrBufferFull)
		case "ErrFinalToken":
			return reflect.ValueOf(&bufio.ErrFinalToken)
		case "ErrInvalidUnreadByte":
			return reflect.ValueOf(&bufio.ErrInvalidUnreadByte)
		case "ErrInvalidUnreadRune":
			return reflect.ValueOf(&bufio.ErrInvalidUnreadRune)
		case "ErrNegativeAdvance":
			return reflect.ValueOf(&bufio.ErrNegativeAdvance)
		case "ErrNegativeCount":
			return reflect.ValueOf(&bufio.ErrNegativeCount)
		case "ErrTooLong":
			return reflect.ValueOf(&bufio.ErrTooLong)
		case "NewReadWriter":
			return reflect.ValueOf(bufio.NewReadWriter)
		case "NewReader":
			return reflect.ValueOf(bufio.NewReader)
		case "NewReaderSize":
			return reflect.ValueOf(bufio.NewReaderSize)
		case "NewScanner":
			return reflect.ValueOf(bufio.NewScanner)
		case "NewWriter":
			return reflect.ValueOf(bufio.NewWriter)
		case "NewWriterSize":
			return reflect.ValueOf(bufio.NewWriterSize)
		case "ScanBytes":
			return reflect.ValueOf(bufio.ScanBytes)
		case "ScanLines":
			return reflect.ValueOf(bufio.ScanLines)
		case "ScanRunes":
			return reflect.ValueOf(bufio.ScanRunes)
		case "ScanWords":
			return reflect.ValueOf(bufio.ScanWords)
		}
	case "bytes":
		switch topLevelName {
		case "Compare":
			return reflect.ValueOf(bytes.Compare)
		case "Contains":
			return reflect.ValueOf(bytes.Contains)
		case "ContainsAny":
			return reflect.ValueOf(bytes.ContainsAny)
		case "ContainsRune":
			return reflect.ValueOf(bytes.ContainsRune)
		case "Count":
			return reflect.ValueOf(bytes.Count)
		case "Cut":
			return reflect.ValueOf(bytes.Cut)
		case "Equal":
			return reflect.ValueOf(bytes.Equal)
		case "EqualFold":
			return reflect.ValueOf(bytes.EqualFold)
		case "ErrTooLarge":
			return reflect.ValueOf(&bytes.ErrTooLarge)
		case "Fields":
			return reflect.ValueOf(bytes.Fields)
		case "FieldsFunc":
			return reflect.ValueOf(bytes.FieldsFunc)
		case "HasPrefix":
			return reflect.ValueOf(bytes.HasPrefix)
		case "HasSuffix":
			return reflect.ValueOf(bytes.HasSuffix)
		case "Index":
			return reflect.ValueOf(bytes.Index)
		case "IndexAny":
			return reflect.ValueOf(bytes.IndexAny)
		case "IndexByte":
			return reflect.ValueOf(bytes.IndexByte)
		case "IndexFunc":
			return reflect.ValueOf(bytes.IndexFunc)
		case "IndexRune":
			return reflect.ValueOf(bytes.IndexRune)
		case "Join":
			return reflect.ValueOf(bytes.Join)
		case "LastIndex":
			return reflect.ValueOf(bytes.LastIndex)
		case "LastIndexAny":
			return reflect.ValueOf(bytes.LastIndexAny)
		case "LastIndexByte":
			return reflect.ValueOf(bytes.LastIndexByte)
		case "LastIndexFunc":
			return reflect.ValueOf(bytes.LastIndexFunc)
		case "Map":
			return reflect.ValueOf(bytes.Map)
		case "NewBuffer":
			return reflect.ValueOf(bytes.NewBuffer)
		case "NewBufferString":
			return reflect.ValueOf(bytes.NewBufferString)
		case "NewReader":
			return reflect.ValueOf(bytes.NewReader)
		case "Repeat":
			return reflect.ValueOf(bytes.Repeat)
		case "Replace":
			return reflect.ValueOf(bytes.Replace)
		case "ReplaceAll":
			return reflect.ValueOf(bytes.ReplaceAll)
		case "Runes":
			return reflect.ValueOf(bytes.Runes)
		case "Split":
			return reflect.ValueOf(bytes.Split)
		case "SplitAfter":
			return reflect.ValueOf(bytes.SplitAfter)
		case "SplitAfterN":
			return reflect.ValueOf(bytes.SplitAfterN)
		case "SplitN":
			return reflect.ValueOf(bytes.SplitN)
		case "Title":
			return reflect.ValueOf(bytes.Title)
		case "ToLower":
			return reflect.ValueOf(bytes.ToLower)
		case "ToLowerSpecial":
			return reflect.ValueOf(bytes.ToLowerSpecial)
		case "ToTitle":
			return reflect.ValueOf(bytes.ToTitle)
		case "ToTitleSpecial":
			return reflect.ValueOf(bytes.ToTitleSpecial)
		case "ToUpper":
			return reflect.ValueOf(bytes.ToUpper)
		case "ToUpperSpecial":
			return reflect.ValueOf(bytes.ToUpperSpecial)
		case "ToValidUTF8":
			return reflect.ValueOf(bytes.ToValidUTF8)
		case "Trim":
			return reflect.ValueOf(bytes.Trim)
		case "TrimFunc":
			return reflect.ValueOf(bytes.TrimFunc)
		case "TrimLeft":
			return reflect.ValueOf(bytes.TrimLeft)
		case "TrimLeftFunc":
			return reflect.ValueOf(bytes.TrimLeftFunc)
		case "TrimPrefix":
			return reflect.ValueOf(bytes.TrimPrefix)
		case "TrimRight":
			return reflect.ValueOf(bytes.TrimRight)
		case "TrimRightFunc":
			return reflect.ValueOf(bytes.TrimRightFunc)
		case "TrimSpace":
			return reflect.ValueOf(bytes.TrimSpace)
		case "TrimSuffix":
			return reflect.ValueOf(bytes.TrimSuffix)
		}
	case "compress/bzip2":
		switch topLevelName {
		case "NewReader":
			return reflect.ValueOf(bzip2.NewReader)
		}
	case "compress/flate":
		switch topLevelName {
		case "NewReader":
			return reflect.ValueOf(flate.NewReader)
		case "NewReaderDict":
			return reflect.ValueOf(flate.NewReaderDict)
		case "NewWriter":
			return reflect.ValueOf(flate.NewWriter)
		case "NewWriterDict":
			return reflect.ValueOf(flate.NewWriterDict)
		}
	case "compress/gzip":
		switch topLevelName {
		case "ErrChecksum":
			return reflect.ValueOf(&gzip.ErrChecksum)
		case "ErrHeader":
			return reflect.ValueOf(&gzip.ErrHeader)
		case "NewReader":
			return reflect.ValueOf(gzip.NewReader)
		case "NewWriter":
			return reflect.ValueOf(gzip.NewWriter)
		case "NewWriterLevel":
			return reflect.ValueOf(gzip.NewWriterLevel)
		}
	case "compress/lzw":
		switch topLevelName {
		case "NewReader":
			return reflect.ValueOf(lzw.NewReader)
		case "NewWriter":
			return reflect.ValueOf(lzw.NewWriter)
		}
	case "compress/zlib":
		switch topLevelName {
		case "ErrChecksum":
			return reflect.ValueOf(&zlib.ErrChecksum)
		case "ErrDictionary":
			return reflect.ValueOf(&zlib.ErrDictionary)
		case "ErrHeader":
			return reflect.ValueOf(&zlib.ErrHeader)
		case "NewReader":
			return reflect.ValueOf(zlib.NewReader)
		case "NewReaderDict":
			return reflect.ValueOf(zlib.NewReaderDict)
		case "NewWriter":
			return reflect.ValueOf(zlib.NewWriter)
		case "NewWriterLevel":
			return reflect.ValueOf(zlib.NewWriterLevel)
		case "NewWriterLevelDict":
			return reflect.ValueOf(zlib.NewWriterLevelDict)
		}
	case "container/heap":
		switch topLevelName {
		case "Fix":
			return reflect.ValueOf(heap.Fix)
		case "Init":
			return reflect.ValueOf(heap.Init)
		case "Pop":
			return reflect.ValueOf(heap.Pop)
		case "Push":
			return reflect.ValueOf(heap.Push)
		case "Remove":
			return reflect.ValueOf(heap.Remove)
		}
	case "container/list":
		switch topLevelName {
		case "New":
			return reflect.ValueOf(list.New)
		}
	case "container/ring":
		switch topLevelName {
		case "New":
			return reflect.ValueOf(ring.New)
		}
	case "context":
		switch topLevelName {
		case "Background":
			return reflect.ValueOf(context.Background)
		case "Canceled":
			return reflect.ValueOf(&context.Canceled)
		case "DeadlineExceeded":
			return reflect.ValueOf(&context.DeadlineExceeded)
		case "TODO":
			return reflect.ValueOf(context.TODO)
		case "WithCancel":
			return reflect.ValueOf(context.WithCancel)
		case "WithDeadline":
			return reflect.ValueOf(context.WithDeadline)
		case "WithTimeout":
			return reflect.ValueOf(context.WithTimeout)
		case "WithValue":
			return reflect.ValueOf(context.WithValue)
		}
	case "crypto":
		switch topLevelName {
		case "RegisterHash":
			return reflect.ValueOf(crypto.RegisterHash)
		}
	case "crypto/aes":
		switch topLevelName {
		case "NewCipher":
			return reflect.ValueOf(aes.NewCipher)
		}
	case "crypto/cipher":
		switch topLevelName {
		case "NewCBCDecrypter":
			return reflect.ValueOf(cipher.NewCBCDecrypter)
		case "NewCBCEncrypter":
			return reflect.ValueOf(cipher.NewCBCEncrypter)
		case "NewCFBDecrypter":
			return reflect.ValueOf(cipher.NewCFBDecrypter)
		case "NewCFBEncrypter":
			return reflect.ValueOf(cipher.NewCFBEncrypter)
		case "NewCTR":
			return reflect.ValueOf(cipher.NewCTR)
		case "NewGCM":
			return reflect.ValueOf(cipher.NewGCM)
		case "NewGCMWithNonceSize":
			return reflect.ValueOf(cipher.NewGCMWithNonceSize)
		case "NewGCMWithTagSize":
			return reflect.ValueOf(cipher.NewGCMWithTagSize)
		case "NewOFB":
			return reflect.ValueOf(cipher.NewOFB)
		}
	case "crypto/des":
		switch topLevelName {
		case "NewCipher":
			return reflect.ValueOf(des.NewCipher)
		case "NewTripleDESCipher":
			return reflect.ValueOf(des.NewTripleDESCipher)
		}
	case "crypto/dsa":
		switch topLevelName {
		case "ErrInvalidPublicKey":
			return reflect.ValueOf(&dsa.ErrInvalidPublicKey)
		case "GenerateKey":
			return reflect.ValueOf(dsa.GenerateKey)
		case "GenerateParameters":
			return reflect.ValueOf(dsa.GenerateParameters)
		case "Sign":
			return reflect.ValueOf(dsa.Sign)
		case "Verify":
			return reflect.ValueOf(dsa.Verify)
		}
	case "crypto/ecdsa":
		switch topLevelName {
		case "GenerateKey":
			return reflect.ValueOf(ecdsa.GenerateKey)
		case "Sign":
			return reflect.ValueOf(ecdsa.Sign)
		case "SignASN1":
			return reflect.ValueOf(ecdsa.SignASN1)
		case "Verify":
			return reflect.ValueOf(ecdsa.Verify)
		case "VerifyASN1":
			return reflect.ValueOf(ecdsa.VerifyASN1)
		}
	case "crypto/ed25519":
		switch topLevelName {
		case "GenerateKey":
			return reflect.ValueOf(ed25519.GenerateKey)
		case "NewKeyFromSeed":
			return reflect.ValueOf(ed25519.NewKeyFromSeed)
		case "Sign":
			return reflect.ValueOf(ed25519.Sign)
		case "Verify":
			return reflect.ValueOf(ed25519.Verify)
		}
	case "crypto/elliptic":
		switch topLevelName {
		case "GenerateKey":
			return reflect.ValueOf(elliptic.GenerateKey)
		case "Marshal":
			return reflect.ValueOf(elliptic.Marshal)
		case "MarshalCompressed":
			return reflect.ValueOf(elliptic.MarshalCompressed)
		case "P224":
			return reflect.ValueOf(elliptic.P224)
		case "P256":
			return reflect.ValueOf(elliptic.P256)
		case "P384":
			return reflect.ValueOf(elliptic.P384)
		case "P521":
			return reflect.ValueOf(elliptic.P521)
		case "Unmarshal":
			return reflect.ValueOf(elliptic.Unmarshal)
		case "UnmarshalCompressed":
			return reflect.ValueOf(elliptic.UnmarshalCompressed)
		}
	case "crypto/hmac":
		switch topLevelName {
		case "Equal":
			return reflect.ValueOf(hmac.Equal)
		case "New":
			return reflect.ValueOf(hmac.New)
		}
	case "crypto/md5":
		switch topLevelName {
		case "New":
			return reflect.ValueOf(md5.New)
		case "Sum":
			return reflect.ValueOf(md5.Sum)
		}
	case "crypto/rand":
		switch topLevelName {
		case "Int":
			return reflect.ValueOf(rand.Int)
		case "Prime":
			return reflect.ValueOf(rand.Prime)
		case "Read":
			return reflect.ValueOf(rand.Read)
		case "Reader":
			return reflect.ValueOf(&rand.Reader)
		}
	case "crypto/rc4":
		switch topLevelName {
		case "NewCipher":
			return reflect.ValueOf(rc4.NewCipher)
		}
	case "crypto/rsa":
		switch topLevelName {
		case "DecryptOAEP":
			return reflect.ValueOf(rsa.DecryptOAEP)
		case "DecryptPKCS1v15":
			return reflect.ValueOf(rsa.DecryptPKCS1v15)
		case "DecryptPKCS1v15SessionKey":
			return reflect.ValueOf(rsa.DecryptPKCS1v15SessionKey)
		case "EncryptOAEP":
			return reflect.ValueOf(rsa.EncryptOAEP)
		case "EncryptPKCS1v15":
			return reflect.ValueOf(rsa.EncryptPKCS1v15)
		case "ErrDecryption":
			return reflect.ValueOf(&rsa.ErrDecryption)
		case "ErrMessageTooLong":
			return reflect.ValueOf(&rsa.ErrMessageTooLong)
		case "ErrVerification":
			return reflect.ValueOf(&rsa.ErrVerification)
		case "GenerateKey":
			return reflect.ValueOf(rsa.GenerateKey)
		case "GenerateMultiPrimeKey":
			return reflect.ValueOf(rsa.GenerateMultiPrimeKey)
		case "SignPKCS1v15":
			return reflect.ValueOf(rsa.SignPKCS1v15)
		case "SignPSS":
			return reflect.ValueOf(rsa.SignPSS)
		case "VerifyPKCS1v15":
			return reflect.ValueOf(rsa.VerifyPKCS1v15)
		case "VerifyPSS":
			return reflect.ValueOf(rsa.VerifyPSS)
		}
	case "crypto/sha1":
		switch topLevelName {
		case "New":
			return reflect.ValueOf(sha1.New)
		case "Sum":
			return reflect.ValueOf(sha1.Sum)
		}
	case "crypto/sha256":
		switch topLevelName {
		case "New":
			return reflect.ValueOf(sha256.New)
		case "New224":
			return reflect.ValueOf(sha256.New224)
		case "Sum224":
			return reflect.ValueOf(sha256.Sum224)
		case "Sum256":
			return reflect.ValueOf(sha256.Sum256)
		}
	case "crypto/sha512":
		switch topLevelName {
		case "New":
			return reflect.ValueOf(sha512.New)
		case "New384":
			return reflect.ValueOf(sha512.New384)
		case "New512_224":
			return reflect.ValueOf(sha512.New512_224)
		case "New512_256":
			return reflect.ValueOf(sha512.New512_256)
		case "Sum384":
			return reflect.ValueOf(sha512.Sum384)
		case "Sum512":
			return reflect.ValueOf(sha512.Sum512)
		case "Sum512_224":
			return reflect.ValueOf(sha512.Sum512_224)
		case "Sum512_256":
			return reflect.ValueOf(sha512.Sum512_256)
		}
	case "crypto/subtle":
		switch topLevelName {
		case "ConstantTimeByteEq":
			return reflect.ValueOf(subtle.ConstantTimeByteEq)
		case "ConstantTimeCompare":
			return reflect.ValueOf(subtle.ConstantTimeCompare)
		case "ConstantTimeCopy":
			return reflect.ValueOf(subtle.ConstantTimeCopy)
		case "ConstantTimeEq":
			return reflect.ValueOf(subtle.ConstantTimeEq)
		case "ConstantTimeLessOrEq":
			return reflect.ValueOf(subtle.ConstantTimeLessOrEq)
		case "ConstantTimeSelect":
			return reflect.ValueOf(subtle.ConstantTimeSelect)
		}
	case "crypto/tls":
		switch topLevelName {
		case "CipherSuiteName":
			return reflect.ValueOf(tls.CipherSuiteName)
		case "CipherSuites":
			return reflect.ValueOf(tls.CipherSuites)
		case "Client":
			return reflect.ValueOf(tls.Client)
		case "Dial":
			return reflect.ValueOf(tls.Dial)
		case "DialWithDialer":
			return reflect.ValueOf(tls.DialWithDialer)
		case "InsecureCipherSuites":
			return reflect.ValueOf(tls.InsecureCipherSuites)
		case "Listen":
			return reflect.ValueOf(tls.Listen)
		case "LoadX509KeyPair":
			return reflect.ValueOf(tls.LoadX509KeyPair)
		case "NewLRUClientSessionCache":
			return reflect.ValueOf(tls.NewLRUClientSessionCache)
		case "NewListener":
			return reflect.ValueOf(tls.NewListener)
		case "Server":
			return reflect.ValueOf(tls.Server)
		case "X509KeyPair":
			return reflect.ValueOf(tls.X509KeyPair)
		}
	case "crypto/x509":
		switch topLevelName {
		case "CreateCertificate":
			return reflect.ValueOf(x509.CreateCertificate)
		case "CreateCertificateRequest":
			return reflect.ValueOf(x509.CreateCertificateRequest)
		case "CreateRevocationList":
			return reflect.ValueOf(x509.CreateRevocationList)
		case "DecryptPEMBlock":
			return reflect.ValueOf(x509.DecryptPEMBlock)
		case "EncryptPEMBlock":
			return reflect.ValueOf(x509.EncryptPEMBlock)
		case "ErrUnsupportedAlgorithm":
			return reflect.ValueOf(&x509.ErrUnsupportedAlgorithm)
		case "IncorrectPasswordError":
			return reflect.ValueOf(&x509.IncorrectPasswordError)
		case "IsEncryptedPEMBlock":
			return reflect.ValueOf(x509.IsEncryptedPEMBlock)
		case "MarshalECPrivateKey":
			return reflect.ValueOf(x509.MarshalECPrivateKey)
		case "MarshalPKCS1PrivateKey":
			return reflect.ValueOf(x509.MarshalPKCS1PrivateKey)
		case "MarshalPKCS1PublicKey":
			return reflect.ValueOf(x509.MarshalPKCS1PublicKey)
		case "MarshalPKCS8PrivateKey":
			return reflect.ValueOf(x509.MarshalPKCS8PrivateKey)
		case "MarshalPKIXPublicKey":
			return reflect.ValueOf(x509.MarshalPKIXPublicKey)
		case "NewCertPool":
			return reflect.ValueOf(x509.NewCertPool)
		case "ParseCRL":
			return reflect.ValueOf(x509.ParseCRL)
		case "ParseCertificate":
			return reflect.ValueOf(x509.ParseCertificate)
		case "ParseCertificateRequest":
			return reflect.ValueOf(x509.ParseCertificateRequest)
		case "ParseCertificates":
			return reflect.ValueOf(x509.ParseCertificates)
		case "ParseDERCRL":
			return reflect.ValueOf(x509.ParseDERCRL)
		case "ParseECPrivateKey":
			return reflect.ValueOf(x509.ParseECPrivateKey)
		case "ParsePKCS1PrivateKey":
			return reflect.ValueOf(x509.ParsePKCS1PrivateKey)
		case "ParsePKCS1PublicKey":
			return reflect.ValueOf(x509.ParsePKCS1PublicKey)
		case "ParsePKCS8PrivateKey":
			return reflect.ValueOf(x509.ParsePKCS8PrivateKey)
		case "ParsePKIXPublicKey":
			return reflect.ValueOf(x509.ParsePKIXPublicKey)
		case "SystemCertPool":
			return reflect.ValueOf(x509.SystemCertPool)
		}
	case "database/sql":
		switch topLevelName {
		case "Drivers":
			return reflect.ValueOf(sql.Drivers)
		case "ErrConnDone":
			return reflect.ValueOf(&sql.ErrConnDone)
		case "ErrNoRows":
			return reflect.ValueOf(&sql.ErrNoRows)
		case "ErrTxDone":
			return reflect.ValueOf(&sql.ErrTxDone)
		case "Named":
			return reflect.ValueOf(sql.Named)
		case "Open":
			return reflect.ValueOf(sql.Open)
		case "OpenDB":
			return reflect.ValueOf(sql.OpenDB)
		case "Register":
			return reflect.ValueOf(sql.Register)
		}
	case "database/sql/driver":
		switch topLevelName {
		case "Bool":
			return reflect.ValueOf(&driver.Bool)
		case "DefaultParameterConverter":
			return reflect.ValueOf(&driver.DefaultParameterConverter)
		case "ErrBadConn":
			return reflect.ValueOf(&driver.ErrBadConn)
		case "ErrRemoveArgument":
			return reflect.ValueOf(&driver.ErrRemoveArgument)
		case "ErrSkip":
			return reflect.ValueOf(&driver.ErrSkip)
		case "Int32":
			return reflect.ValueOf(&driver.Int32)
		case "IsScanValue":
			return reflect.ValueOf(driver.IsScanValue)
		case "IsValue":
			return reflect.ValueOf(driver.IsValue)
		case "ResultNoRows":
			return reflect.ValueOf(&driver.ResultNoRows)
		case "String":
			return reflect.ValueOf(&driver.String)
		}
	case "debug/buildinfo":
		switch topLevelName {
		case "Read":
			return reflect.ValueOf(buildinfo.Read)
		case "ReadFile":
			return reflect.ValueOf(buildinfo.ReadFile)
		}
	case "debug/dwarf":
		switch topLevelName {
		case "ErrUnknownPC":
			return reflect.ValueOf(&dwarf.ErrUnknownPC)
		case "New":
			return reflect.ValueOf(dwarf.New)
		}
	case "debug/elf":
		switch topLevelName {
		case "ErrNoSymbols":
			return reflect.ValueOf(&elf.ErrNoSymbols)
		case "NewFile":
			return reflect.ValueOf(elf.NewFile)
		case "Open":
			return reflect.ValueOf(elf.Open)
		case "R_INFO":
			return reflect.ValueOf(elf.R_INFO)
		case "R_INFO32":
			return reflect.ValueOf(elf.R_INFO32)
		case "R_SYM32":
			return reflect.ValueOf(elf.R_SYM32)
		case "R_SYM64":
			return reflect.ValueOf(elf.R_SYM64)
		case "R_TYPE32":
			return reflect.ValueOf(elf.R_TYPE32)
		case "R_TYPE64":
			return reflect.ValueOf(elf.R_TYPE64)
		case "ST_BIND":
			return reflect.ValueOf(elf.ST_BIND)
		case "ST_INFO":
			return reflect.ValueOf(elf.ST_INFO)
		case "ST_TYPE":
			return reflect.ValueOf(elf.ST_TYPE)
		case "ST_VISIBILITY":
			return reflect.ValueOf(elf.ST_VISIBILITY)
		}
	case "debug/gosym":
		switch topLevelName {
		case "NewLineTable":
			return reflect.ValueOf(gosym.NewLineTable)
		case "NewTable":
			return reflect.ValueOf(gosym.NewTable)
		}
	case "debug/macho":
		switch topLevelName {
		case "ErrNotFat":
			return reflect.ValueOf(&macho.ErrNotFat)
		case "NewFatFile":
			return reflect.ValueOf(macho.NewFatFile)
		case "NewFile":
			return reflect.ValueOf(macho.NewFile)
		case "Open":
			return reflect.ValueOf(macho.Open)
		case "OpenFat":
			return reflect.ValueOf(macho.OpenFat)
		}
	case "debug/pe":
		switch topLevelName {
		case "NewFile":
			return reflect.ValueOf(pe.NewFile)
		case "Open":
			return reflect.ValueOf(pe.Open)
		}
	case "debug/plan9obj":
		switch topLevelName {
		case "ErrNoSymbols":
			return reflect.ValueOf(&plan9obj.ErrNoSymbols)
		case "NewFile":
			return reflect.ValueOf(plan9obj.NewFile)
		case "Open":
			return reflect.ValueOf(plan9obj.Open)
		}
	case "encoding/ascii85":
		switch topLevelName {
		case "Decode":
			return reflect.ValueOf(ascii85.Decode)
		case "Encode":
			return reflect.ValueOf(ascii85.Encode)
		case "MaxEncodedLen":
			return reflect.ValueOf(ascii85.MaxEncodedLen)
		case "NewDecoder":
			return reflect.ValueOf(ascii85.NewDecoder)
		case "NewEncoder":
			return reflect.ValueOf(ascii85.NewEncoder)
		}
	case "encoding/asn1":
		switch topLevelName {
		case "Marshal":
			return reflect.ValueOf(asn1.Marshal)
		case "MarshalWithParams":
			return reflect.ValueOf(asn1.MarshalWithParams)
		case "NullBytes":
			return reflect.ValueOf(&asn1.NullBytes)
		case "NullRawValue":
			return reflect.ValueOf(&asn1.NullRawValue)
		case "Unmarshal":
			return reflect.ValueOf(asn1.Unmarshal)
		case "UnmarshalWithParams":
			return reflect.ValueOf(asn1.UnmarshalWithParams)
		}
	case "encoding/base32":
		switch topLevelName {
		case "HexEncoding":
			return reflect.ValueOf(&base32.HexEncoding)
		case "NewDecoder":
			return reflect.ValueOf(base32.NewDecoder)
		case "NewEncoder":
			return reflect.ValueOf(base32.NewEncoder)
		case "NewEncoding":
			return reflect.ValueOf(base32.NewEncoding)
		case "StdEncoding":
			return reflect.ValueOf(&base32.StdEncoding)
		}
	case "encoding/base64":
		switch topLevelName {
		case "NewDecoder":
			return reflect.ValueOf(base64.NewDecoder)
		case "NewEncoder":
			return reflect.ValueOf(base64.NewEncoder)
		case "NewEncoding":
			return reflect.ValueOf(base64.NewEncoding)
		case "RawStdEncoding":
			return reflect.ValueOf(&base64.RawStdEncoding)
		case "RawURLEncoding":
			return reflect.ValueOf(&base64.RawURLEncoding)
		case "StdEncoding":
			return reflect.ValueOf(&base64.StdEncoding)
		case "URLEncoding":
			return reflect.ValueOf(&base64.URLEncoding)
		}
	case "encoding/binary":
		switch topLevelName {
		case "BigEndian":
			return reflect.ValueOf(&binary.BigEndian)
		case "LittleEndian":
			return reflect.ValueOf(&binary.LittleEndian)
		case "PutUvarint":
			return reflect.ValueOf(binary.PutUvarint)
		case "PutVarint":
			return reflect.ValueOf(binary.PutVarint)
		case "Read":
			return reflect.ValueOf(binary.Read)
		case "ReadUvarint":
			return reflect.ValueOf(binary.ReadUvarint)
		case "ReadVarint":
			return reflect.ValueOf(binary.ReadVarint)
		case "Size":
			return reflect.ValueOf(binary.Size)
		case "Uvarint":
			return reflect.ValueOf(binary.Uvarint)
		case "Varint":
			return reflect.ValueOf(binary.Varint)
		case "Write":
			return reflect.ValueOf(binary.Write)
		}
	case "encoding/csv":
		switch topLevelName {
		case "ErrBareQuote":
			return reflect.ValueOf(&csv.ErrBareQuote)
		case "ErrFieldCount":
			return reflect.ValueOf(&csv.ErrFieldCount)
		case "ErrQuote":
			return reflect.ValueOf(&csv.ErrQuote)
		case "ErrTrailingComma":
			return reflect.ValueOf(&csv.ErrTrailingComma)
		case "NewReader":
			return reflect.ValueOf(csv.NewReader)
		case "NewWriter":
			return reflect.ValueOf(csv.NewWriter)
		}
	case "encoding/gob":
		switch topLevelName {
		case "NewDecoder":
			return reflect.ValueOf(gob.NewDecoder)
		case "NewEncoder":
			return reflect.ValueOf(gob.NewEncoder)
		case "Register":
			return reflect.ValueOf(gob.Register)
		case "RegisterName":
			return reflect.ValueOf(gob.RegisterName)
		}
	case "encoding/hex":
		switch topLevelName {
		case "Decode":
			return reflect.ValueOf(hex.Decode)
		case "DecodeString":
			return reflect.ValueOf(hex.DecodeString)
		case "DecodedLen":
			return reflect.ValueOf(hex.DecodedLen)
		case "Dump":
			return reflect.ValueOf(hex.Dump)
		case "Dumper":
			return reflect.ValueOf(hex.Dumper)
		case "Encode":
			return reflect.ValueOf(hex.Encode)
		case "EncodeToString":
			return reflect.ValueOf(hex.EncodeToString)
		case "EncodedLen":
			return reflect.ValueOf(hex.EncodedLen)
		case "ErrLength":
			return reflect.ValueOf(&hex.ErrLength)
		case "NewDecoder":
			return reflect.ValueOf(hex.NewDecoder)
		case "NewEncoder":
			return reflect.ValueOf(hex.NewEncoder)
		}
	case "encoding/json":
		switch topLevelName {
		case "Compact":
			return reflect.ValueOf(json.Compact)
		case "HTMLEscape":
			return reflect.ValueOf(json.HTMLEscape)
		case "Indent":
			return reflect.ValueOf(json.Indent)
		case "Marshal":
			return reflect.ValueOf(json.Marshal)
		case "MarshalIndent":
			return reflect.ValueOf(json.MarshalIndent)
		case "NewDecoder":
			return reflect.ValueOf(json.NewDecoder)
		case "NewEncoder":
			return reflect.ValueOf(json.NewEncoder)
		case "Unmarshal":
			return reflect.ValueOf(json.Unmarshal)
		case "Valid":
			return reflect.ValueOf(json.Valid)
		}
	case "encoding/pem":
		switch topLevelName {
		case "Decode":
			return reflect.ValueOf(pem.Decode)
		case "Encode":
			return reflect.ValueOf(pem.Encode)
		case "EncodeToMemory":
			return reflect.ValueOf(pem.EncodeToMemory)
		}
	case "encoding/xml":
		switch topLevelName {
		case "CopyToken":
			return reflect.ValueOf(xml.CopyToken)
		case "Escape":
			return reflect.ValueOf(xml.Escape)
		case "EscapeText":
			return reflect.ValueOf(xml.EscapeText)
		case "HTMLAutoClose":
			return reflect.ValueOf(&xml.HTMLAutoClose)
		case "HTMLEntity":
			return reflect.ValueOf(&xml.HTMLEntity)
		case "Marshal":
			return reflect.ValueOf(xml.Marshal)
		case "MarshalIndent":
			return reflect.ValueOf(xml.MarshalIndent)
		case "NewDecoder":
			return reflect.ValueOf(xml.NewDecoder)
		case "NewEncoder":
			return reflect.ValueOf(xml.NewEncoder)
		case "NewTokenDecoder":
			return reflect.ValueOf(xml.NewTokenDecoder)
		case "Unmarshal":
			return reflect.ValueOf(xml.Unmarshal)
		}
	case "errors":
		switch topLevelName {
		case "As":
			return reflect.ValueOf(errors.As)
		case "Is":
			return reflect.ValueOf(errors.Is)
		case "New":
			return reflect.ValueOf(errors.New)
		case "Unwrap":
			return reflect.ValueOf(errors.Unwrap)
		}
	case "expvar":
		switch topLevelName {
		case "Do":
			return reflect.ValueOf(expvar.Do)
		case "Get":
			return reflect.ValueOf(expvar.Get)
		case "Handler":
			return reflect.ValueOf(expvar.Handler)
		case "NewFloat":
			return reflect.ValueOf(expvar.NewFloat)
		case "NewInt":
			return reflect.ValueOf(expvar.NewInt)
		case "NewMap":
			return reflect.ValueOf(expvar.NewMap)
		case "NewString":
			return reflect.ValueOf(expvar.NewString)
		case "Publish":
			return reflect.ValueOf(expvar.Publish)
		}
	case "flag":
		switch topLevelName {
		case "Arg":
			return reflect.ValueOf(flag.Arg)
		case "Args":
			return reflect.ValueOf(flag.Args)
		case "Bool":
			return reflect.ValueOf(flag.Bool)
		case "BoolVar":
			return reflect.ValueOf(flag.BoolVar)
		case "CommandLine":
			return reflect.ValueOf(&flag.CommandLine)
		case "Duration":
			return reflect.ValueOf(flag.Duration)
		case "DurationVar":
			return reflect.ValueOf(flag.DurationVar)
		case "ErrHelp":
			return reflect.ValueOf(&flag.ErrHelp)
		case "Float64":
			return reflect.ValueOf(flag.Float64)
		case "Float64Var":
			return reflect.ValueOf(flag.Float64Var)
		case "Func":
			return reflect.ValueOf(flag.Func)
		case "Int":
			return reflect.ValueOf(flag.Int)
		case "Int64":
			return reflect.ValueOf(flag.Int64)
		case "Int64Var":
			return reflect.ValueOf(flag.Int64Var)
		case "IntVar":
			return reflect.ValueOf(flag.IntVar)
		case "Lookup":
			return reflect.ValueOf(flag.Lookup)
		case "NArg":
			return reflect.ValueOf(flag.NArg)
		case "NFlag":
			return reflect.ValueOf(flag.NFlag)
		case "NewFlagSet":
			return reflect.ValueOf(flag.NewFlagSet)
		case "Parse":
			return reflect.ValueOf(flag.Parse)
		case "Parsed":
			return reflect.ValueOf(flag.Parsed)
		case "PrintDefaults":
			return reflect.ValueOf(flag.PrintDefaults)
		case "Set":
			return reflect.ValueOf(flag.Set)
		case "String":
			return reflect.ValueOf(flag.String)
		case "StringVar":
			return reflect.ValueOf(flag.StringVar)
		case "Uint":
			return reflect.ValueOf(flag.Uint)
		case "Uint64":
			return reflect.ValueOf(flag.Uint64)
		case "Uint64Var":
			return reflect.ValueOf(flag.Uint64Var)
		case "UintVar":
			return reflect.ValueOf(flag.UintVar)
		case "UnquoteUsage":
			return reflect.ValueOf(flag.UnquoteUsage)
		case "Usage":
			return reflect.ValueOf(&flag.Usage)
		case "Var":
			return reflect.ValueOf(flag.Var)
		case "Visit":
			return reflect.ValueOf(flag.Visit)
		case "VisitAll":
			return reflect.ValueOf(flag.VisitAll)
		}
	case "fmt":
		switch topLevelName {
		case "Errorf":
			return reflect.ValueOf(fmt.Errorf)
		case "Fprint":
			return reflect.ValueOf(fmt.Fprint)
		case "Fprintf":
			return reflect.ValueOf(fmt.Fprintf)
		case "Fprintln":
			return reflect.ValueOf(fmt.Fprintln)
		case "Fscan":
			return reflect.ValueOf(fmt.Fscan)
		case "Fscanf":
			return reflect.ValueOf(fmt.Fscanf)
		case "Fscanln":
			return reflect.ValueOf(fmt.Fscanln)
		case "Print":
			return reflect.ValueOf(fmt.Print)
		case "Printf":
			return reflect.ValueOf(fmt.Printf)
		case "Println":
			return reflect.ValueOf(fmt.Println)
		case "Scan":
			return reflect.ValueOf(fmt.Scan)
		case "Scanf":
			return reflect.ValueOf(fmt.Scanf)
		case "Scanln":
			return reflect.ValueOf(fmt.Scanln)
		case "Sprint":
			return reflect.ValueOf(fmt.Sprint)
		case "Sprintf":
			return reflect.ValueOf(fmt.Sprintf)
		case "Sprintln":
			return reflect.ValueOf(fmt.Sprintln)
		case "Sscan":
			return reflect.ValueOf(fmt.Sscan)
		case "Sscanf":
			return reflect.ValueOf(fmt.Sscanf)
		case "Sscanln":
			return reflect.ValueOf(fmt.Sscanln)
		}
	case "go/ast":
		switch topLevelName {
		case "FileExports":
			return reflect.ValueOf(ast.FileExports)
		case "FilterDecl":
			return reflect.ValueOf(ast.FilterDecl)
		case "FilterFile":
			return reflect.ValueOf(ast.FilterFile)
		case "FilterPackage":
			return reflect.ValueOf(ast.FilterPackage)
		case "Fprint":
			return reflect.ValueOf(ast.Fprint)
		case "Inspect":
			return reflect.ValueOf(ast.Inspect)
		case "IsExported":
			return reflect.ValueOf(ast.IsExported)
		case "MergePackageFiles":
			return reflect.ValueOf(ast.MergePackageFiles)
		case "NewCommentMap":
			return reflect.ValueOf(ast.NewCommentMap)
		case "NewIdent":
			return reflect.ValueOf(ast.NewIdent)
		case "NewObj":
			return reflect.ValueOf(ast.NewObj)
		case "NewPackage":
			return reflect.ValueOf(ast.NewPackage)
		case "NewScope":
			return reflect.ValueOf(ast.NewScope)
		case "NotNilFilter":
			return reflect.ValueOf(ast.NotNilFilter)
		case "PackageExports":
			return reflect.ValueOf(ast.PackageExports)
		case "Print":
			return reflect.ValueOf(ast.Print)
		case "SortImports":
			return reflect.ValueOf(ast.SortImports)
		case "Walk":
			return reflect.ValueOf(ast.Walk)
		}
	case "go/build":
		switch topLevelName {
		case "ArchChar":
			return reflect.ValueOf(build.ArchChar)
		case "Default":
			return reflect.ValueOf(&build.Default)
		case "Import":
			return reflect.ValueOf(build.Import)
		case "ImportDir":
			return reflect.ValueOf(build.ImportDir)
		case "IsLocalImport":
			return reflect.ValueOf(build.IsLocalImport)
		case "ToolDir":
			return reflect.ValueOf(&build.ToolDir)
		}
	case "go/build/constraint":
		switch topLevelName {
		case "IsGoBuild":
			return reflect.ValueOf(constraint.IsGoBuild)
		case "IsPlusBuild":
			return reflect.ValueOf(constraint.IsPlusBuild)
		case "Parse":
			return reflect.ValueOf(constraint.Parse)
		case "PlusBuildLines":
			return reflect.ValueOf(constraint.PlusBuildLines)
		}
	case "go/constant":
		switch topLevelName {
		case "BinaryOp":
			return reflect.ValueOf(constant.BinaryOp)
		case "BitLen":
			return reflect.ValueOf(constant.BitLen)
		case "BoolVal":
			return reflect.ValueOf(constant.BoolVal)
		case "Bytes":
			return reflect.ValueOf(constant.Bytes)
		case "Compare":
			return reflect.ValueOf(constant.Compare)
		case "Denom":
			return reflect.ValueOf(constant.Denom)
		case "Float32Val":
			return reflect.ValueOf(constant.Float32Val)
		case "Float64Val":
			return reflect.ValueOf(constant.Float64Val)
		case "Imag":
			return reflect.ValueOf(constant.Imag)
		case "Int64Val":
			return reflect.ValueOf(constant.Int64Val)
		case "Make":
			return reflect.ValueOf(constant.Make)
		case "MakeBool":
			return reflect.ValueOf(constant.MakeBool)
		case "MakeFloat64":
			return reflect.ValueOf(constant.MakeFloat64)
		case "MakeFromBytes":
			return reflect.ValueOf(constant.MakeFromBytes)
		case "MakeFromLiteral":
			return reflect.ValueOf(constant.MakeFromLiteral)
		case "MakeImag":
			return reflect.ValueOf(constant.MakeImag)
		case "MakeInt64":
			return reflect.ValueOf(constant.MakeInt64)
		case "MakeString":
			return reflect.ValueOf(constant.MakeString)
		case "MakeUint64":
			return reflect.ValueOf(constant.MakeUint64)
		case "MakeUnknown":
			return reflect.ValueOf(constant.MakeUnknown)
		case "Num":
			return reflect.ValueOf(constant.Num)
		case "Real":
			return reflect.ValueOf(constant.Real)
		case "Shift":
			return reflect.ValueOf(constant.Shift)
		case "Sign":
			return reflect.ValueOf(constant.Sign)
		case "StringVal":
			return reflect.ValueOf(constant.StringVal)
		case "ToComplex":
			return reflect.ValueOf(constant.ToComplex)
		case "ToFloat":
			return reflect.ValueOf(constant.ToFloat)
		case "ToInt":
			return reflect.ValueOf(constant.ToInt)
		case "Uint64Val":
			return reflect.ValueOf(constant.Uint64Val)
		case "UnaryOp":
			return reflect.ValueOf(constant.UnaryOp)
		case "Val":
			return reflect.ValueOf(constant.Val)
		}
	case "go/doc":
		switch topLevelName {
		case "Examples":
			return reflect.ValueOf(doc.Examples)
		case "IllegalPrefixes":
			return reflect.ValueOf(&doc.IllegalPrefixes)
		case "IsPredeclared":
			return reflect.ValueOf(doc.IsPredeclared)
		case "New":
			return reflect.ValueOf(doc.New)
		case "NewFromFiles":
			return reflect.ValueOf(doc.NewFromFiles)
		case "Synopsis":
			return reflect.ValueOf(doc.Synopsis)
		case "ToHTML":
			return reflect.ValueOf(doc.ToHTML)
		case "ToText":
			return reflect.ValueOf(doc.ToText)
		}
	case "go/format":
		switch topLevelName {
		case "Node":
			return reflect.ValueOf(format.Node)
		case "Source":
			return reflect.ValueOf(format.Source)
		}
	case "go/importer":
		switch topLevelName {
		case "Default":
			return reflect.ValueOf(importer.Default)
		case "For":
			return reflect.ValueOf(importer.For)
		case "ForCompiler":
			return reflect.ValueOf(importer.ForCompiler)
		}
	case "go/parser":
		switch topLevelName {
		case "ParseDir":
			return reflect.ValueOf(parser.ParseDir)
		case "ParseExpr":
			return reflect.ValueOf(parser.ParseExpr)
		case "ParseExprFrom":
			return reflect.ValueOf(parser.ParseExprFrom)
		case "ParseFile":
			return reflect.ValueOf(parser.ParseFile)
		}
	case "go/printer":
		switch topLevelName {
		case "Fprint":
			return reflect.ValueOf(printer.Fprint)
		}
	case "go/scanner":
		switch topLevelName {
		case "PrintError":
			return reflect.ValueOf(scanner.PrintError)
		}
	case "go/token":
		switch topLevelName {
		case "IsExported":
			return reflect.ValueOf(token.IsExported)
		case "IsIdentifier":
			return reflect.ValueOf(token.IsIdentifier)
		case "IsKeyword":
			return reflect.ValueOf(token.IsKeyword)
		case "Lookup":
			return reflect.ValueOf(token.Lookup)
		case "NewFileSet":
			return reflect.ValueOf(token.NewFileSet)
		}
	case "go/types":
		switch topLevelName {
		case "AssertableTo":
			return reflect.ValueOf(types.AssertableTo)
		case "AssignableTo":
			return reflect.ValueOf(types.AssignableTo)
		case "CheckExpr":
			return reflect.ValueOf(types.CheckExpr)
		case "Comparable":
			return reflect.ValueOf(types.Comparable)
		case "ConvertibleTo":
			return reflect.ValueOf(types.ConvertibleTo)
		case "DefPredeclaredTestFuncs":
			return reflect.ValueOf(types.DefPredeclaredTestFuncs)
		case "Default":
			return reflect.ValueOf(types.Default)
		case "Eval":
			return reflect.ValueOf(types.Eval)
		case "ExprString":
			return reflect.ValueOf(types.ExprString)
		case "Id":
			return reflect.ValueOf(types.Id)
		case "Identical":
			return reflect.ValueOf(types.Identical)
		case "IdenticalIgnoreTags":
			return reflect.ValueOf(types.IdenticalIgnoreTags)
		case "Implements":
			return reflect.ValueOf(types.Implements)
		case "Instantiate":
			return reflect.ValueOf(types.Instantiate)
		case "IsInterface":
			return reflect.ValueOf(types.IsInterface)
		case "LookupFieldOrMethod":
			return reflect.ValueOf(types.LookupFieldOrMethod)
		case "MissingMethod":
			return reflect.ValueOf(types.MissingMethod)
		case "NewArray":
			return reflect.ValueOf(types.NewArray)
		case "NewChan":
			return reflect.ValueOf(types.NewChan)
		case "NewChecker":
			return reflect.ValueOf(types.NewChecker)
		case "NewConst":
			return reflect.ValueOf(types.NewConst)
		case "NewContext":
			return reflect.ValueOf(types.NewContext)
		case "NewField":
			return reflect.ValueOf(types.NewField)
		case "NewFunc":
			return reflect.ValueOf(types.NewFunc)
		case "NewInterface":
			return reflect.ValueOf(types.NewInterface)
		case "NewInterfaceType":
			return reflect.ValueOf(types.NewInterfaceType)
		case "NewLabel":
			return reflect.ValueOf(types.NewLabel)
		case "NewMap":
			return reflect.ValueOf(types.NewMap)
		case "NewMethodSet":
			return reflect.ValueOf(types.NewMethodSet)
		case "NewNamed":
			return reflect.ValueOf(types.NewNamed)
		case "NewPackage":
			return reflect.ValueOf(types.NewPackage)
		case "NewParam":
			return reflect.ValueOf(types.NewParam)
		case "NewPkgName":
			return reflect.ValueOf(types.NewPkgName)
		case "NewPointer":
			return reflect.ValueOf(types.NewPointer)
		case "NewScope":
			return reflect.ValueOf(types.NewScope)
		case "NewSignature":
			return reflect.ValueOf(types.NewSignature)
		case "NewSignatureType":
			return reflect.ValueOf(types.NewSignatureType)
		case "NewSlice":
			return reflect.ValueOf(types.NewSlice)
		case "NewStruct":
			return reflect.ValueOf(types.NewStruct)
		case "NewTerm":
			return reflect.ValueOf(types.NewTerm)
		case "NewTuple":
			return reflect.ValueOf(types.NewTuple)
		case "NewTypeName":
			return reflect.ValueOf(types.NewTypeName)
		case "NewTypeParam":
			return reflect.ValueOf(types.NewTypeParam)
		case "NewUnion":
			return reflect.ValueOf(types.NewUnion)
		case "NewVar":
			return reflect.ValueOf(types.NewVar)
		case "ObjectString":
			return reflect.ValueOf(types.ObjectString)
		case "RelativeTo":
			return reflect.ValueOf(types.RelativeTo)
		case "SelectionString":
			return reflect.ValueOf(types.SelectionString)
		case "SizesFor":
			return reflect.ValueOf(types.SizesFor)
		case "Typ":
			return reflect.ValueOf(&types.Typ)
		case "TypeString":
			return reflect.ValueOf(types.TypeString)
		case "Universe":
			return reflect.ValueOf(&types.Universe)
		case "Unsafe":
			return reflect.ValueOf(&types.Unsafe)
		case "WriteExpr":
			return reflect.ValueOf(types.WriteExpr)
		case "WriteSignature":
			return reflect.ValueOf(types.WriteSignature)
		case "WriteType":
			return reflect.ValueOf(types.WriteType)
		}
	case "hash/adler32":
		switch topLevelName {
		case "Checksum":
			return reflect.ValueOf(adler32.Checksum)
		case "New":
			return reflect.ValueOf(adler32.New)
		}
	case "hash/crc32":
		switch topLevelName {
		case "Checksum":
			return reflect.ValueOf(crc32.Checksum)
		case "ChecksumIEEE":
			return reflect.ValueOf(crc32.ChecksumIEEE)
		case "IEEETable":
			return reflect.ValueOf(&crc32.IEEETable)
		case "MakeTable":
			return reflect.ValueOf(crc32.MakeTable)
		case "New":
			return reflect.ValueOf(crc32.New)
		case "NewIEEE":
			return reflect.ValueOf(crc32.NewIEEE)
		case "Update":
			return reflect.ValueOf(crc32.Update)
		}
	case "hash/crc64":
		switch topLevelName {
		case "Checksum":
			return reflect.ValueOf(crc64.Checksum)
		case "MakeTable":
			return reflect.ValueOf(crc64.MakeTable)
		case "New":
			return reflect.ValueOf(crc64.New)
		case "Update":
			return reflect.ValueOf(crc64.Update)
		}
	case "hash/fnv":
		switch topLevelName {
		case "New128":
			return reflect.ValueOf(fnv.New128)
		case "New128a":
			return reflect.ValueOf(fnv.New128a)
		case "New32":
			return reflect.ValueOf(fnv.New32)
		case "New32a":
			return reflect.ValueOf(fnv.New32a)
		case "New64":
			return reflect.ValueOf(fnv.New64)
		case "New64a":
			return reflect.ValueOf(fnv.New64a)
		}
	case "hash/maphash":
		switch topLevelName {
		case "MakeSeed":
			return reflect.ValueOf(maphash.MakeSeed)
		}
	case "html":
		switch topLevelName {
		case "EscapeString":
			return reflect.ValueOf(html.EscapeString)
		case "UnescapeString":
			return reflect.ValueOf(html.UnescapeString)
		}
	case "html/template":
		switch topLevelName {
		case "HTMLEscape":
			return reflect.ValueOf(template.HTMLEscape)
		case "HTMLEscapeString":
			return reflect.ValueOf(template.HTMLEscapeString)
		case "HTMLEscaper":
			return reflect.ValueOf(template.HTMLEscaper)
		case "IsTrue":
			return reflect.ValueOf(template.IsTrue)
		case "JSEscape":
			return reflect.ValueOf(template.JSEscape)
		case "JSEscapeString":
			return reflect.ValueOf(template.JSEscapeString)
		case "JSEscaper":
			return reflect.ValueOf(template.JSEscaper)
		case "Must":
			return reflect.ValueOf(template.Must)
		case "New":
			return reflect.ValueOf(template.New)
		case "ParseFS":
			return reflect.ValueOf(template.ParseFS)
		case "ParseFiles":
			return reflect.ValueOf(template.ParseFiles)
		case "ParseGlob":
			return reflect.ValueOf(template.ParseGlob)
		case "URLQueryEscaper":
			return reflect.ValueOf(template.URLQueryEscaper)
		}
	case "image":
		switch topLevelName {
		case "Black":
			return reflect.ValueOf(&image.Black)
		case "Decode":
			return reflect.ValueOf(image.Decode)
		case "DecodeConfig":
			return reflect.ValueOf(image.DecodeConfig)
		case "ErrFormat":
			return reflect.ValueOf(&image.ErrFormat)
		case "NewAlpha":
			return reflect.ValueOf(image.NewAlpha)
		case "NewAlpha16":
			return reflect.ValueOf(image.NewAlpha16)
		case "NewCMYK":
			return reflect.ValueOf(image.NewCMYK)
		case "NewGray":
			return reflect.ValueOf(image.NewGray)
		case "NewGray16":
			return reflect.ValueOf(image.NewGray16)
		case "NewNRGBA":
			return reflect.ValueOf(image.NewNRGBA)
		case "NewNRGBA64":
			return reflect.ValueOf(image.NewNRGBA64)
		case "NewNYCbCrA":
			return reflect.ValueOf(image.NewNYCbCrA)
		case "NewPaletted":
			return reflect.ValueOf(image.NewPaletted)
		case "NewRGBA":
			return reflect.ValueOf(image.NewRGBA)
		case "NewRGBA64":
			return reflect.ValueOf(image.NewRGBA64)
		case "NewUniform":
			return reflect.ValueOf(image.NewUniform)
		case "NewYCbCr":
			return reflect.ValueOf(image.NewYCbCr)
		case "Opaque":
			return reflect.ValueOf(&image.Opaque)
		case "Pt":
			return reflect.ValueOf(image.Pt)
		case "Rect":
			return reflect.ValueOf(image.Rect)
		case "RegisterFormat":
			return reflect.ValueOf(image.RegisterFormat)
		case "Transparent":
			return reflect.ValueOf(&image.Transparent)
		case "White":
			return reflect.ValueOf(&image.White)
		case "ZP":
			return reflect.ValueOf(&image.ZP)
		case "ZR":
			return reflect.ValueOf(&image.ZR)
		}
	case "image/color":
		switch topLevelName {
		case "Alpha16Model":
			return reflect.ValueOf(&color.Alpha16Model)
		case "AlphaModel":
			return reflect.ValueOf(&color.AlphaModel)
		case "Black":
			return reflect.ValueOf(&color.Black)
		case "CMYKModel":
			return reflect.ValueOf(&color.CMYKModel)
		case "CMYKToRGB":
			return reflect.ValueOf(color.CMYKToRGB)
		case "Gray16Model":
			return reflect.ValueOf(&color.Gray16Model)
		case "GrayModel":
			return reflect.ValueOf(&color.GrayModel)
		case "ModelFunc":
			return reflect.ValueOf(color.ModelFunc)
		case "NRGBA64Model":
			return reflect.ValueOf(&color.NRGBA64Model)
		case "NRGBAModel":
			return reflect.ValueOf(&color.NRGBAModel)
		case "NYCbCrAModel":
			return reflect.ValueOf(&color.NYCbCrAModel)
		case "Opaque":
			return reflect.ValueOf(&color.Opaque)
		case "RGBA64Model":
			return reflect.ValueOf(&color.RGBA64Model)
		case "RGBAModel":
			return reflect.ValueOf(&color.RGBAModel)
		case "RGBToCMYK":
			return reflect.ValueOf(color.RGBToCMYK)
		case "RGBToYCbCr":
			return reflect.ValueOf(color.RGBToYCbCr)
		case "Transparent":
			return reflect.ValueOf(&color.Transparent)
		case "White":
			return reflect.ValueOf(&color.White)
		case "YCbCrModel":
			return reflect.ValueOf(&color.YCbCrModel)
		case "YCbCrToRGB":
			return reflect.ValueOf(color.YCbCrToRGB)
		}
	case "image/color/palette":
		switch topLevelName {
		case "Plan9":
			return reflect.ValueOf(&palette.Plan9)
		case "WebSafe":
			return reflect.ValueOf(&palette.WebSafe)
		}
	case "image/draw":
		switch topLevelName {
		case "Draw":
			return reflect.ValueOf(draw.Draw)
		case "DrawMask":
			return reflect.ValueOf(draw.DrawMask)
		case "FloydSteinberg":
			return reflect.ValueOf(&draw.FloydSteinberg)
		}
	case "image/gif":
		switch topLevelName {
		case "Decode":
			return reflect.ValueOf(gif.Decode)
		case "DecodeAll":
			return reflect.ValueOf(gif.DecodeAll)
		case "DecodeConfig":
			return reflect.ValueOf(gif.DecodeConfig)
		case "Encode":
			return reflect.ValueOf(gif.Encode)
		case "EncodeAll":
			return reflect.ValueOf(gif.EncodeAll)
		}
	case "image/jpeg":
		switch topLevelName {
		case "Decode":
			return reflect.ValueOf(jpeg.Decode)
		case "DecodeConfig":
			return reflect.ValueOf(jpeg.DecodeConfig)
		case "Encode":
			return reflect.ValueOf(jpeg.Encode)
		}
	case "image/png":
		switch topLevelName {
		case "Decode":
			return reflect.ValueOf(png.Decode)
		case "DecodeConfig":
			return reflect.ValueOf(png.DecodeConfig)
		case "Encode":
			return reflect.ValueOf(png.Encode)
		}
	case "index/suffixarray":
		switch topLevelName {
		case "New":
			return reflect.ValueOf(suffixarray.New)
		}
	case "io":
		switch topLevelName {
		case "Copy":
			return reflect.ValueOf(io.Copy)
		case "CopyBuffer":
			return reflect.ValueOf(io.CopyBuffer)
		case "CopyN":
			return reflect.ValueOf(io.CopyN)
		case "Discard":
			return reflect.ValueOf(&io.Discard)
		case "EOF":
			return reflect.ValueOf(&io.EOF)
		case "ErrClosedPipe":
			return reflect.ValueOf(&io.ErrClosedPipe)
		case "ErrNoProgress":
			return reflect.ValueOf(&io.ErrNoProgress)
		case "ErrShortBuffer":
			return reflect.ValueOf(&io.ErrShortBuffer)
		case "ErrShortWrite":
			return reflect.ValueOf(&io.ErrShortWrite)
		case "ErrUnexpectedEOF":
			return reflect.ValueOf(&io.ErrUnexpectedEOF)
		case "LimitReader":
			return reflect.ValueOf(io.LimitReader)
		case "MultiReader":
			return reflect.ValueOf(io.MultiReader)
		case "MultiWriter":
			return reflect.ValueOf(io.MultiWriter)
		case "NewSectionReader":
			return reflect.ValueOf(io.NewSectionReader)
		case "NopCloser":
			return reflect.ValueOf(io.NopCloser)
		case "Pipe":
			return reflect.ValueOf(io.Pipe)
		case "ReadAll":
			return reflect.ValueOf(io.ReadAll)
		case "ReadAtLeast":
			return reflect.ValueOf(io.ReadAtLeast)
		case "ReadFull":
			return reflect.ValueOf(io.ReadFull)
		case "TeeReader":
			return reflect.ValueOf(io.TeeReader)
		case "WriteString":
			return reflect.ValueOf(io.WriteString)
		}
	case "io/fs":
		switch topLevelName {
		case "ErrClosed":
			return reflect.ValueOf(&fs.ErrClosed)
		case "ErrExist":
			return reflect.ValueOf(&fs.ErrExist)
		case "ErrInvalid":
			return reflect.ValueOf(&fs.ErrInvalid)
		case "ErrNotExist":
			return reflect.ValueOf(&fs.ErrNotExist)
		case "ErrPermission":
			return reflect.ValueOf(&fs.ErrPermission)
		case "FileInfoToDirEntry":
			return reflect.ValueOf(fs.FileInfoToDirEntry)
		case "Glob":
			return reflect.ValueOf(fs.Glob)
		case "ReadDir":
			return reflect.ValueOf(fs.ReadDir)
		case "ReadFile":
			return reflect.ValueOf(fs.ReadFile)
		case "SkipDir":
			return reflect.ValueOf(&fs.SkipDir)
		case "Stat":
			return reflect.ValueOf(fs.Stat)
		case "Sub":
			return reflect.ValueOf(fs.Sub)
		case "ValidPath":
			return reflect.ValueOf(fs.ValidPath)
		case "WalkDir":
			return reflect.ValueOf(fs.WalkDir)
		}
	case "io/ioutil":
		switch topLevelName {
		case "Discard":
			return reflect.ValueOf(&ioutil.Discard)
		case "NopCloser":
			return reflect.ValueOf(ioutil.NopCloser)
		case "ReadAll":
			return reflect.ValueOf(ioutil.ReadAll)
		case "ReadDir":
			return reflect.ValueOf(ioutil.ReadDir)
		case "ReadFile":
			return reflect.ValueOf(ioutil.ReadFile)
		case "TempDir":
			return reflect.ValueOf(ioutil.TempDir)
		case "TempFile":
			return reflect.ValueOf(ioutil.TempFile)
		case "WriteFile":
			return reflect.ValueOf(ioutil.WriteFile)
		}
	case "log":
		switch topLevelName {
		case "Default":
			return reflect.ValueOf(log.Default)
		case "Fatal":
			return reflect.ValueOf(log.Fatal)
		case "Fatalf":
			return reflect.ValueOf(log.Fatalf)
		case "Fatalln":
			return reflect.ValueOf(log.Fatalln)
		case "Flags":
			return reflect.ValueOf(log.Flags)
		case "New":
			return reflect.ValueOf(log.New)
		case "Output":
			return reflect.ValueOf(log.Output)
		case "Panic":
			return reflect.ValueOf(log.Panic)
		case "Panicf":
			return reflect.ValueOf(log.Panicf)
		case "Panicln":
			return reflect.ValueOf(log.Panicln)
		case "Prefix":
			return reflect.ValueOf(log.Prefix)
		case "Print":
			return reflect.ValueOf(log.Print)
		case "Printf":
			return reflect.ValueOf(log.Printf)
		case "Println":
			return reflect.ValueOf(log.Println)
		case "SetFlags":
			return reflect.ValueOf(log.SetFlags)
		case "SetOutput":
			return reflect.ValueOf(log.SetOutput)
		case "SetPrefix":
			return reflect.ValueOf(log.SetPrefix)
		case "Writer":
			return reflect.ValueOf(log.Writer)
		}
	case "math":
		switch topLevelName {
		case "Abs":
			return reflect.ValueOf(math.Abs)
		case "Acos":
			return reflect.ValueOf(math.Acos)
		case "Acosh":
			return reflect.ValueOf(math.Acosh)
		case "Asin":
			return reflect.ValueOf(math.Asin)
		case "Asinh":
			return reflect.ValueOf(math.Asinh)
		case "Atan":
			return reflect.ValueOf(math.Atan)
		case "Atan2":
			return reflect.ValueOf(math.Atan2)
		case "Atanh":
			return reflect.ValueOf(math.Atanh)
		case "Cbrt":
			return reflect.ValueOf(math.Cbrt)
		case "Ceil":
			return reflect.ValueOf(math.Ceil)
		case "Copysign":
			return reflect.ValueOf(math.Copysign)
		case "Cos":
			return reflect.ValueOf(math.Cos)
		case "Cosh":
			return reflect.ValueOf(math.Cosh)
		case "Dim":
			return reflect.ValueOf(math.Dim)
		case "Erf":
			return reflect.ValueOf(math.Erf)
		case "Erfc":
			return reflect.ValueOf(math.Erfc)
		case "Erfcinv":
			return reflect.ValueOf(math.Erfcinv)
		case "Erfinv":
			return reflect.ValueOf(math.Erfinv)
		case "Exp":
			return reflect.ValueOf(math.Exp)
		case "Exp2":
			return reflect.ValueOf(math.Exp2)
		case "Expm1":
			return reflect.ValueOf(math.Expm1)
		case "FMA":
			return reflect.ValueOf(math.FMA)
		case "Float32bits":
			return reflect.ValueOf(math.Float32bits)
		case "Float32frombits":
			return reflect.ValueOf(math.Float32frombits)
		case "Float64bits":
			return reflect.ValueOf(math.Float64bits)
		case "Float64frombits":
			return reflect.ValueOf(math.Float64frombits)
		case "Floor":
			return reflect.ValueOf(math.Floor)
		case "Frexp":
			return reflect.ValueOf(math.Frexp)
		case "Gamma":
			return reflect.ValueOf(math.Gamma)
		case "Hypot":
			return reflect.ValueOf(math.Hypot)
		case "Ilogb":
			return reflect.ValueOf(math.Ilogb)
		case "Inf":
			return reflect.ValueOf(math.Inf)
		case "IsInf":
			return reflect.ValueOf(math.IsInf)
		case "IsNaN":
			return reflect.ValueOf(math.IsNaN)
		case "J0":
			return reflect.ValueOf(math.J0)
		case "J1":
			return reflect.ValueOf(math.J1)
		case "Jn":
			return reflect.ValueOf(math.Jn)
		case "Ldexp":
			return reflect.ValueOf(math.Ldexp)
		case "Lgamma":
			return reflect.ValueOf(math.Lgamma)
		case "Log":
			return reflect.ValueOf(math.Log)
		case "Log10":
			return reflect.ValueOf(math.Log10)
		case "Log1p":
			return reflect.ValueOf(math.Log1p)
		case "Log2":
			return reflect.ValueOf(math.Log2)
		case "Logb":
			return reflect.ValueOf(math.Logb)
		case "Max":
			return reflect.ValueOf(math.Max)
		case "Min":
			return reflect.ValueOf(math.Min)
		case "Mod":
			return reflect.ValueOf(math.Mod)
		case "Modf":
			return reflect.ValueOf(math.Modf)
		case "NaN":
			return reflect.ValueOf(math.NaN)
		case "Nextafter":
			return reflect.ValueOf(math.Nextafter)
		case "Nextafter32":
			return reflect.ValueOf(math.Nextafter32)
		case "Pow":
			return reflect.ValueOf(math.Pow)
		case "Pow10":
			return reflect.ValueOf(math.Pow10)
		case "Remainder":
			return reflect.ValueOf(math.Remainder)
		case "Round":
			return reflect.ValueOf(math.Round)
		case "RoundToEven":
			return reflect.ValueOf(math.RoundToEven)
		case "Signbit":
			return reflect.ValueOf(math.Signbit)
		case "Sin":
			return reflect.ValueOf(math.Sin)
		case "Sincos":
			return reflect.ValueOf(math.Sincos)
		case "Sinh":
			return reflect.ValueOf(math.Sinh)
		case "Sqrt":
			return reflect.ValueOf(math.Sqrt)
		case "Tan":
			return reflect.ValueOf(math.Tan)
		case "Tanh":
			return reflect.ValueOf(math.Tanh)
		case "Trunc":
			return reflect.ValueOf(math.Trunc)
		case "Y0":
			return reflect.ValueOf(math.Y0)
		case "Y1":
			return reflect.ValueOf(math.Y1)
		case "Yn":
			return reflect.ValueOf(math.Yn)
		}
	case "math/big":
		switch topLevelName {
		case "Jacobi":
			return reflect.ValueOf(big.Jacobi)
		case "NewFloat":
			return reflect.ValueOf(big.NewFloat)
		case "NewInt":
			return reflect.ValueOf(big.NewInt)
		case "NewRat":
			return reflect.ValueOf(big.NewRat)
		case "ParseFloat":
			return reflect.ValueOf(big.ParseFloat)
		}
	case "math/bits":
		switch topLevelName {
		case "Add":
			return reflect.ValueOf(bits.Add)
		case "Add32":
			return reflect.ValueOf(bits.Add32)
		case "Add64":
			return reflect.ValueOf(bits.Add64)
		case "Div":
			return reflect.ValueOf(bits.Div)
		case "Div32":
			return reflect.ValueOf(bits.Div32)
		case "Div64":
			return reflect.ValueOf(bits.Div64)
		case "LeadingZeros":
			return reflect.ValueOf(bits.LeadingZeros)
		case "LeadingZeros16":
			return reflect.ValueOf(bits.LeadingZeros16)
		case "LeadingZeros32":
			return reflect.ValueOf(bits.LeadingZeros32)
		case "LeadingZeros64":
			return reflect.ValueOf(bits.LeadingZeros64)
		case "LeadingZeros8":
			return reflect.ValueOf(bits.LeadingZeros8)
		case "Len":
			return reflect.ValueOf(bits.Len)
		case "Len16":
			return reflect.ValueOf(bits.Len16)
		case "Len32":
			return reflect.ValueOf(bits.Len32)
		case "Len64":
			return reflect.ValueOf(bits.Len64)
		case "Len8":
			return reflect.ValueOf(bits.Len8)
		case "Mul":
			return reflect.ValueOf(bits.Mul)
		case "Mul32":
			return reflect.ValueOf(bits.Mul32)
		case "Mul64":
			return reflect.ValueOf(bits.Mul64)
		case "OnesCount":
			return reflect.ValueOf(bits.OnesCount)
		case "OnesCount16":
			return reflect.ValueOf(bits.OnesCount16)
		case "OnesCount32":
			return reflect.ValueOf(bits.OnesCount32)
		case "OnesCount64":
			return reflect.ValueOf(bits.OnesCount64)
		case "OnesCount8":
			return reflect.ValueOf(bits.OnesCount8)
		case "Rem":
			return reflect.ValueOf(bits.Rem)
		case "Rem32":
			return reflect.ValueOf(bits.Rem32)
		case "Rem64":
			return reflect.ValueOf(bits.Rem64)
		case "Reverse":
			return reflect.ValueOf(bits.Reverse)
		case "Reverse16":
			return reflect.ValueOf(bits.Reverse16)
		case "Reverse32":
			return reflect.ValueOf(bits.Reverse32)
		case "Reverse64":
			return reflect.ValueOf(bits.Reverse64)
		case "Reverse8":
			return reflect.ValueOf(bits.Reverse8)
		case "ReverseBytes":
			return reflect.ValueOf(bits.ReverseBytes)
		case "ReverseBytes16":
			return reflect.ValueOf(bits.ReverseBytes16)
		case "ReverseBytes32":
			return reflect.ValueOf(bits.ReverseBytes32)
		case "ReverseBytes64":
			return reflect.ValueOf(bits.ReverseBytes64)
		case "RotateLeft":
			return reflect.ValueOf(bits.RotateLeft)
		case "RotateLeft16":
			return reflect.ValueOf(bits.RotateLeft16)
		case "RotateLeft32":
			return reflect.ValueOf(bits.RotateLeft32)
		case "RotateLeft64":
			return reflect.ValueOf(bits.RotateLeft64)
		case "RotateLeft8":
			return reflect.ValueOf(bits.RotateLeft8)
		case "Sub":
			return reflect.ValueOf(bits.Sub)
		case "Sub32":
			return reflect.ValueOf(bits.Sub32)
		case "Sub64":
			return reflect.ValueOf(bits.Sub64)
		case "TrailingZeros":
			return reflect.ValueOf(bits.TrailingZeros)
		case "TrailingZeros16":
			return reflect.ValueOf(bits.TrailingZeros16)
		case "TrailingZeros32":
			return reflect.ValueOf(bits.TrailingZeros32)
		case "TrailingZeros64":
			return reflect.ValueOf(bits.TrailingZeros64)
		case "TrailingZeros8":
			return reflect.ValueOf(bits.TrailingZeros8)
		}
	case "math/cmplx":
		switch topLevelName {
		case "Abs":
			return reflect.ValueOf(cmplx.Abs)
		case "Acos":
			return reflect.ValueOf(cmplx.Acos)
		case "Acosh":
			return reflect.ValueOf(cmplx.Acosh)
		case "Asin":
			return reflect.ValueOf(cmplx.Asin)
		case "Asinh":
			return reflect.ValueOf(cmplx.Asinh)
		case "Atan":
			return reflect.ValueOf(cmplx.Atan)
		case "Atanh":
			return reflect.ValueOf(cmplx.Atanh)
		case "Conj":
			return reflect.ValueOf(cmplx.Conj)
		case "Cos":
			return reflect.ValueOf(cmplx.Cos)
		case "Cosh":
			return reflect.ValueOf(cmplx.Cosh)
		case "Cot":
			return reflect.ValueOf(cmplx.Cot)
		case "Exp":
			return reflect.ValueOf(cmplx.Exp)
		case "Inf":
			return reflect.ValueOf(cmplx.Inf)
		case "IsInf":
			return reflect.ValueOf(cmplx.IsInf)
		case "IsNaN":
			return reflect.ValueOf(cmplx.IsNaN)
		case "Log":
			return reflect.ValueOf(cmplx.Log)
		case "Log10":
			return reflect.ValueOf(cmplx.Log10)
		case "NaN":
			return reflect.ValueOf(cmplx.NaN)
		case "Phase":
			return reflect.ValueOf(cmplx.Phase)
		case "Polar":
			return reflect.ValueOf(cmplx.Polar)
		case "Pow":
			return reflect.ValueOf(cmplx.Pow)
		case "Rect":
			return reflect.ValueOf(cmplx.Rect)
		case "Sin":
			return reflect.ValueOf(cmplx.Sin)
		case "Sinh":
			return reflect.ValueOf(cmplx.Sinh)
		case "Sqrt":
			return reflect.ValueOf(cmplx.Sqrt)
		case "Tan":
			return reflect.ValueOf(cmplx.Tan)
		case "Tanh":
			return reflect.ValueOf(cmplx.Tanh)
		}
	case "math/rand":
		switch topLevelName {
		case "ExpFloat64":
			return reflect.ValueOf(rand1.ExpFloat64)
		case "Float32":
			return reflect.ValueOf(rand1.Float32)
		case "Float64":
			return reflect.ValueOf(rand1.Float64)
		case "Int":
			return reflect.ValueOf(rand1.Int)
		case "Int31":
			return reflect.ValueOf(rand1.Int31)
		case "Int31n":
			return reflect.ValueOf(rand1.Int31n)
		case "Int63":
			return reflect.ValueOf(rand1.Int63)
		case "Int63n":
			return reflect.ValueOf(rand1.Int63n)
		case "Intn":
			return reflect.ValueOf(rand1.Intn)
		case "New":
			return reflect.ValueOf(rand1.New)
		case "NewSource":
			return reflect.ValueOf(rand1.NewSource)
		case "NewZipf":
			return reflect.ValueOf(rand1.NewZipf)
		case "NormFloat64":
			return reflect.ValueOf(rand1.NormFloat64)
		case "Perm":
			return reflect.ValueOf(rand1.Perm)
		case "Read":
			return reflect.ValueOf(rand1.Read)
		case "Seed":
			return reflect.ValueOf(rand1.Seed)
		case "Shuffle":
			return reflect.ValueOf(rand1.Shuffle)
		case "Uint32":
			return reflect.ValueOf(rand1.Uint32)
		case "Uint64":
			return reflect.ValueOf(rand1.Uint64)
		}
	case "mime":
		switch topLevelName {
		case "AddExtensionType":
			return reflect.ValueOf(mime.AddExtensionType)
		case "ErrInvalidMediaParameter":
			return reflect.ValueOf(&mime.ErrInvalidMediaParameter)
		case "ExtensionsByType":
			return reflect.ValueOf(mime.ExtensionsByType)
		case "FormatMediaType":
			return reflect.ValueOf(mime.FormatMediaType)
		case "ParseMediaType":
			return reflect.ValueOf(mime.ParseMediaType)
		case "TypeByExtension":
			return reflect.ValueOf(mime.TypeByExtension)
		}
	case "mime/multipart":
		switch topLevelName {
		case "ErrMessageTooLarge":
			return reflect.ValueOf(&multipart.ErrMessageTooLarge)
		case "NewReader":
			return reflect.ValueOf(multipart.NewReader)
		case "NewWriter":
			return reflect.ValueOf(multipart.NewWriter)
		}
	case "mime/quotedprintable":
		switch topLevelName {
		case "NewReader":
			return reflect.ValueOf(quotedprintable.NewReader)
		case "NewWriter":
			return reflect.ValueOf(quotedprintable.NewWriter)
		}
	case "net":
		switch topLevelName {
		case "CIDRMask":
			return reflect.ValueOf(net.CIDRMask)
		case "DefaultResolver":
			return reflect.ValueOf(&net.DefaultResolver)
		case "Dial":
			return reflect.ValueOf(net.Dial)
		case "DialIP":
			return reflect.ValueOf(net.DialIP)
		case "DialTCP":
			return reflect.ValueOf(net.DialTCP)
		case "DialTimeout":
			return reflect.ValueOf(net.DialTimeout)
		case "DialUDP":
			return reflect.ValueOf(net.DialUDP)
		case "DialUnix":
			return reflect.ValueOf(net.DialUnix)
		case "ErrClosed":
			return reflect.ValueOf(&net.ErrClosed)
		case "ErrWriteToConnected":
			return reflect.ValueOf(&net.ErrWriteToConnected)
		case "FileConn":
			return reflect.ValueOf(net.FileConn)
		case "FileListener":
			return reflect.ValueOf(net.FileListener)
		case "FilePacketConn":
			return reflect.ValueOf(net.FilePacketConn)
		case "IPv4":
			return reflect.ValueOf(net.IPv4)
		case "IPv4Mask":
			return reflect.ValueOf(net.IPv4Mask)
		case "IPv4allrouter":
			return reflect.ValueOf(&net.IPv4allrouter)
		case "IPv4allsys":
			return reflect.ValueOf(&net.IPv4allsys)
		case "IPv4bcast":
			return reflect.ValueOf(&net.IPv4bcast)
		case "IPv4zero":
			return reflect.ValueOf(&net.IPv4zero)
		case "IPv6interfacelocalallnodes":
			return reflect.ValueOf(&net.IPv6interfacelocalallnodes)
		case "IPv6linklocalallnodes":
			return reflect.ValueOf(&net.IPv6linklocalallnodes)
		case "IPv6linklocalallrouters":
			return reflect.ValueOf(&net.IPv6linklocalallrouters)
		case "IPv6loopback":
			return reflect.ValueOf(&net.IPv6loopback)
		case "IPv6unspecified":
			return reflect.ValueOf(&net.IPv6unspecified)
		case "IPv6zero":
			return reflect.ValueOf(&net.IPv6zero)
		case "InterfaceAddrs":
			return reflect.ValueOf(net.InterfaceAddrs)
		case "InterfaceByIndex":
			return reflect.ValueOf(net.InterfaceByIndex)
		case "InterfaceByName":
			return reflect.ValueOf(net.InterfaceByName)
		case "Interfaces":
			return reflect.ValueOf(net.Interfaces)
		case "JoinHostPort":
			return reflect.ValueOf(net.JoinHostPort)
		case "Listen":
			return reflect.ValueOf(net.Listen)
		case "ListenIP":
			return reflect.ValueOf(net.ListenIP)
		case "ListenMulticastUDP":
			return reflect.ValueOf(net.ListenMulticastUDP)
		case "ListenPacket":
			return reflect.ValueOf(net.ListenPacket)
		case "ListenTCP":
			return reflect.ValueOf(net.ListenTCP)
		case "ListenUDP":
			return reflect.ValueOf(net.ListenUDP)
		case "ListenUnix":
			return reflect.ValueOf(net.ListenUnix)
		case "ListenUnixgram":
			return reflect.ValueOf(net.ListenUnixgram)
		case "LookupAddr":
			return reflect.ValueOf(net.LookupAddr)
		case "LookupCNAME":
			return reflect.ValueOf(net.LookupCNAME)
		case "LookupHost":
			return reflect.ValueOf(net.LookupHost)
		case "LookupIP":
			return reflect.ValueOf(net.LookupIP)
		case "LookupMX":
			return reflect.ValueOf(net.LookupMX)
		case "LookupNS":
			return reflect.ValueOf(net.LookupNS)
		case "LookupPort":
			return reflect.ValueOf(net.LookupPort)
		case "LookupSRV":
			return reflect.ValueOf(net.LookupSRV)
		case "LookupTXT":
			return reflect.ValueOf(net.LookupTXT)
		case "ParseCIDR":
			return reflect.ValueOf(net.ParseCIDR)
		case "ParseIP":
			return reflect.ValueOf(net.ParseIP)
		case "ParseMAC":
			return reflect.ValueOf(net.ParseMAC)
		case "Pipe":
			return reflect.ValueOf(net.Pipe)
		case "ResolveIPAddr":
			return reflect.ValueOf(net.ResolveIPAddr)
		case "ResolveTCPAddr":
			return reflect.ValueOf(net.ResolveTCPAddr)
		case "ResolveUDPAddr":
			return reflect.ValueOf(net.ResolveUDPAddr)
		case "ResolveUnixAddr":
			return reflect.ValueOf(net.ResolveUnixAddr)
		case "SplitHostPort":
			return reflect.ValueOf(net.SplitHostPort)
		case "TCPAddrFromAddrPort":
			return reflect.ValueOf(net.TCPAddrFromAddrPort)
		case "UDPAddrFromAddrPort":
			return reflect.ValueOf(net.UDPAddrFromAddrPort)
		}
	case "net/http":
		switch topLevelName {
		case "AllowQuerySemicolons":
			return reflect.ValueOf(http.AllowQuerySemicolons)
		case "CanonicalHeaderKey":
			return reflect.ValueOf(http.CanonicalHeaderKey)
		case "DefaultClient":
			return reflect.ValueOf(&http.DefaultClient)
		case "DefaultServeMux":
			return reflect.ValueOf(&http.DefaultServeMux)
		case "DefaultTransport":
			return reflect.ValueOf(&http.DefaultTransport)
		case "DetectContentType":
			return reflect.ValueOf(http.DetectContentType)
		case "ErrAbortHandler":
			return reflect.ValueOf(&http.ErrAbortHandler)
		case "ErrBodyNotAllowed":
			return reflect.ValueOf(&http.ErrBodyNotAllowed)
		case "ErrBodyReadAfterClose":
			return reflect.ValueOf(&http.ErrBodyReadAfterClose)
		case "ErrContentLength":
			return reflect.ValueOf(&http.ErrContentLength)
		case "ErrHandlerTimeout":
			return reflect.ValueOf(&http.ErrHandlerTimeout)
		case "ErrHeaderTooLong":
			return reflect.ValueOf(&http.ErrHeaderTooLong)
		case "ErrHijacked":
			return reflect.ValueOf(&http.ErrHijacked)
		case "ErrLineTooLong":
			return reflect.ValueOf(&http.ErrLineTooLong)
		case "ErrMissingBoundary":
			return reflect.ValueOf(&http.ErrMissingBoundary)
		case "ErrMissingContentLength":
			return reflect.ValueOf(&http.ErrMissingContentLength)
		case "ErrMissingFile":
			return reflect.ValueOf(&http.ErrMissingFile)
		case "ErrNoCookie":
			return reflect.ValueOf(&http.ErrNoCookie)
		case "ErrNoLocation":
			return reflect.ValueOf(&http.ErrNoLocation)
		case "ErrNotMultipart":
			return reflect.ValueOf(&http.ErrNotMultipart)
		case "ErrNotSupported":
			return reflect.ValueOf(&http.ErrNotSupported)
		case "ErrServerClosed":
			return reflect.ValueOf(&http.ErrServerClosed)
		case "ErrShortBody":
			return reflect.ValueOf(&http.ErrShortBody)
		case "ErrSkipAltProtocol":
			return reflect.ValueOf(&http.ErrSkipAltProtocol)
		case "ErrUnexpectedTrailer":
			return reflect.ValueOf(&http.ErrUnexpectedTrailer)
		case "ErrUseLastResponse":
			return reflect.ValueOf(&http.ErrUseLastResponse)
		case "ErrWriteAfterFlush":
			return reflect.ValueOf(&http.ErrWriteAfterFlush)
		case "Error":
			return reflect.ValueOf(http.Error)
		case "FS":
			return reflect.ValueOf(http.FS)
		case "FileServer":
			return reflect.ValueOf(http.FileServer)
		case "Get":
			return reflect.ValueOf(http.Get)
		case "Handle":
			return reflect.ValueOf(http.Handle)
		case "HandleFunc":
			return reflect.ValueOf(http.HandleFunc)
		case "Head":
			return reflect.ValueOf(http.Head)
		case "ListenAndServe":
			return reflect.ValueOf(http.ListenAndServe)
		case "ListenAndServeTLS":
			return reflect.ValueOf(http.ListenAndServeTLS)
		case "LocalAddrContextKey":
			return reflect.ValueOf(&http.LocalAddrContextKey)
		case "MaxBytesHandler":
			return reflect.ValueOf(http.MaxBytesHandler)
		case "MaxBytesReader":
			return reflect.ValueOf(http.MaxBytesReader)
		case "NewFileTransport":
			return reflect.ValueOf(http.NewFileTransport)
		case "NewRequest":
			return reflect.ValueOf(http.NewRequest)
		case "NewRequestWithContext":
			return reflect.ValueOf(http.NewRequestWithContext)
		case "NewServeMux":
			return reflect.ValueOf(http.NewServeMux)
		case "NoBody":
			return reflect.ValueOf(&http.NoBody)
		case "NotFound":
			return reflect.ValueOf(http.NotFound)
		case "NotFoundHandler":
			return reflect.ValueOf(http.NotFoundHandler)
		case "ParseHTTPVersion":
			return reflect.ValueOf(http.ParseHTTPVersion)
		case "ParseTime":
			return reflect.ValueOf(http.ParseTime)
		case "Post":
			return reflect.ValueOf(http.Post)
		case "PostForm":
			return reflect.ValueOf(http.PostForm)
		case "ProxyFromEnvironment":
			return reflect.ValueOf(http.ProxyFromEnvironment)
		case "ProxyURL":
			return reflect.ValueOf(http.ProxyURL)
		case "ReadRequest":
			return reflect.ValueOf(http.ReadRequest)
		case "ReadResponse":
			return reflect.ValueOf(http.ReadResponse)
		case "Redirect":
			return reflect.ValueOf(http.Redirect)
		case "RedirectHandler":
			return reflect.ValueOf(http.RedirectHandler)
		case "Serve":
			return reflect.ValueOf(http.Serve)
		case "ServeContent":
			return reflect.ValueOf(http.ServeContent)
		case "ServeFile":
			return reflect.ValueOf(http.ServeFile)
		case "ServeTLS":
			return reflect.ValueOf(http.ServeTLS)
		case "ServerContextKey":
			return reflect.ValueOf(&http.ServerContextKey)
		case "SetCookie":
			return reflect.ValueOf(http.SetCookie)
		case "StatusText":
			return reflect.ValueOf(http.StatusText)
		case "StripPrefix":
			return reflect.ValueOf(http.StripPrefix)
		case "TimeoutHandler":
			return reflect.ValueOf(http.TimeoutHandler)
		}
	case "net/http/cgi":
		switch topLevelName {
		case "Request":
			return reflect.ValueOf(cgi.Request)
		case "RequestFromMap":
			return reflect.ValueOf(cgi.RequestFromMap)
		case "Serve":
			return reflect.ValueOf(cgi.Serve)
		}
	case "net/http/cookiejar":
		switch topLevelName {
		case "New":
			return reflect.ValueOf(cookiejar.New)
		}
	case "net/http/fcgi":
		switch topLevelName {
		case "ErrConnClosed":
			return reflect.ValueOf(&fcgi.ErrConnClosed)
		case "ErrRequestAborted":
			return reflect.ValueOf(&fcgi.ErrRequestAborted)
		case "ProcessEnv":
			return reflect.ValueOf(fcgi.ProcessEnv)
		case "Serve":
			return reflect.ValueOf(fcgi.Serve)
		}
	case "net/http/httptest":
		switch topLevelName {
		case "NewRecorder":
			return reflect.ValueOf(httptest.NewRecorder)
		case "NewRequest":
			return reflect.ValueOf(httptest.NewRequest)
		case "NewServer":
			return reflect.ValueOf(httptest.NewServer)
		case "NewTLSServer":
			return reflect.ValueOf(httptest.NewTLSServer)
		case "NewUnstartedServer":
			return reflect.ValueOf(httptest.NewUnstartedServer)
		}
	case "net/http/httptrace":
		switch topLevelName {
		case "ContextClientTrace":
			return reflect.ValueOf(httptrace.ContextClientTrace)
		case "WithClientTrace":
			return reflect.ValueOf(httptrace.WithClientTrace)
		}
	case "net/http/httputil":
		switch topLevelName {
		case "DumpRequest":
			return reflect.ValueOf(httputil.DumpRequest)
		case "DumpRequestOut":
			return reflect.ValueOf(httputil.DumpRequestOut)
		case "DumpResponse":
			return reflect.ValueOf(httputil.DumpResponse)
		case "ErrClosed":
			return reflect.ValueOf(&httputil.ErrClosed)
		case "ErrLineTooLong":
			return reflect.ValueOf(&httputil.ErrLineTooLong)
		case "ErrPersistEOF":
			return reflect.ValueOf(&httputil.ErrPersistEOF)
		case "ErrPipeline":
			return reflect.ValueOf(&httputil.ErrPipeline)
		case "NewChunkedReader":
			return reflect.ValueOf(httputil.NewChunkedReader)
		case "NewChunkedWriter":
			return reflect.ValueOf(httputil.NewChunkedWriter)
		case "NewClientConn":
			return reflect.ValueOf(httputil.NewClientConn)
		case "NewProxyClientConn":
			return reflect.ValueOf(httputil.NewProxyClientConn)
		case "NewServerConn":
			return reflect.ValueOf(httputil.NewServerConn)
		case "NewSingleHostReverseProxy":
			return reflect.ValueOf(httputil.NewSingleHostReverseProxy)
		}
	case "net/http/pprof":
		switch topLevelName {
		case "Cmdline":
			return reflect.ValueOf(pprof.Cmdline)
		case "Handler":
			return reflect.ValueOf(pprof.Handler)
		case "Index":
			return reflect.ValueOf(pprof.Index)
		case "Profile":
			return reflect.ValueOf(pprof.Profile)
		case "Symbol":
			return reflect.ValueOf(pprof.Symbol)
		case "Trace":
			return reflect.ValueOf(pprof.Trace)
		}
	case "net/mail":
		switch topLevelName {
		case "ErrHeaderNotPresent":
			return reflect.ValueOf(&mail.ErrHeaderNotPresent)
		case "ParseAddress":
			return reflect.ValueOf(mail.ParseAddress)
		case "ParseAddressList":
			return reflect.ValueOf(mail.ParseAddressList)
		case "ParseDate":
			return reflect.ValueOf(mail.ParseDate)
		case "ReadMessage":
			return reflect.ValueOf(mail.ReadMessage)
		}
	case "net/netip":
		switch topLevelName {
		case "AddrFrom16":
			return reflect.ValueOf(netip.AddrFrom16)
		case "AddrFrom4":
			return reflect.ValueOf(netip.AddrFrom4)
		case "AddrFromSlice":
			return reflect.ValueOf(netip.AddrFromSlice)
		case "AddrPortFrom":
			return reflect.ValueOf(netip.AddrPortFrom)
		case "IPv4Unspecified":
			return reflect.ValueOf(netip.IPv4Unspecified)
		case "IPv6LinkLocalAllNodes":
			return reflect.ValueOf(netip.IPv6LinkLocalAllNodes)
		case "IPv6Unspecified":
			return reflect.ValueOf(netip.IPv6Unspecified)
		case "MustParseAddr":
			return reflect.ValueOf(netip.MustParseAddr)
		case "MustParseAddrPort":
			return reflect.ValueOf(netip.MustParseAddrPort)
		case "MustParsePrefix":
			return reflect.ValueOf(netip.MustParsePrefix)
		case "ParseAddr":
			return reflect.ValueOf(netip.ParseAddr)
		case "ParseAddrPort":
			return reflect.ValueOf(netip.ParseAddrPort)
		case "ParsePrefix":
			return reflect.ValueOf(netip.ParsePrefix)
		case "PrefixFrom":
			return reflect.ValueOf(netip.PrefixFrom)
		}
	case "net/rpc":
		switch topLevelName {
		case "Accept":
			return reflect.ValueOf(rpc.Accept)
		case "DefaultServer":
			return reflect.ValueOf(&rpc.DefaultServer)
		case "Dial":
			return reflect.ValueOf(rpc.Dial)
		case "DialHTTP":
			return reflect.ValueOf(rpc.DialHTTP)
		case "DialHTTPPath":
			return reflect.ValueOf(rpc.DialHTTPPath)
		case "ErrShutdown":
			return reflect.ValueOf(&rpc.ErrShutdown)
		case "HandleHTTP":
			return reflect.ValueOf(rpc.HandleHTTP)
		case "NewClient":
			return reflect.ValueOf(rpc.NewClient)
		case "NewClientWithCodec":
			return reflect.ValueOf(rpc.NewClientWithCodec)
		case "NewServer":
			return reflect.ValueOf(rpc.NewServer)
		case "Register":
			return reflect.ValueOf(rpc.Register)
		case "RegisterName":
			return reflect.ValueOf(rpc.RegisterName)
		case "ServeCodec":
			return reflect.ValueOf(rpc.ServeCodec)
		case "ServeConn":
			return reflect.ValueOf(rpc.ServeConn)
		case "ServeRequest":
			return reflect.ValueOf(rpc.ServeRequest)
		}
	case "net/rpc/jsonrpc":
		switch topLevelName {
		case "Dial":
			return reflect.ValueOf(jsonrpc.Dial)
		case "NewClient":
			return reflect.ValueOf(jsonrpc.NewClient)
		case "NewClientCodec":
			return reflect.ValueOf(jsonrpc.NewClientCodec)
		case "NewServerCodec":
			return reflect.ValueOf(jsonrpc.NewServerCodec)
		case "ServeConn":
			return reflect.ValueOf(jsonrpc.ServeConn)
		}
	case "net/smtp":
		switch topLevelName {
		case "CRAMMD5Auth":
			return reflect.ValueOf(smtp.CRAMMD5Auth)
		case "Dial":
			return reflect.ValueOf(smtp.Dial)
		case "NewClient":
			return reflect.ValueOf(smtp.NewClient)
		case "PlainAuth":
			return reflect.ValueOf(smtp.PlainAuth)
		case "SendMail":
			return reflect.ValueOf(smtp.SendMail)
		}
	case "net/textproto":
		switch topLevelName {
		case "CanonicalMIMEHeaderKey":
			return reflect.ValueOf(textproto.CanonicalMIMEHeaderKey)
		case "Dial":
			return reflect.ValueOf(textproto.Dial)
		case "NewConn":
			return reflect.ValueOf(textproto.NewConn)
		case "NewReader":
			return reflect.ValueOf(textproto.NewReader)
		case "NewWriter":
			return reflect.ValueOf(textproto.NewWriter)
		case "TrimBytes":
			return reflect.ValueOf(textproto.TrimBytes)
		case "TrimString":
			return reflect.ValueOf(textproto.TrimString)
		}
	case "net/url":
		switch topLevelName {
		case "Parse":
			return reflect.ValueOf(url.Parse)
		case "ParseQuery":
			return reflect.ValueOf(url.ParseQuery)
		case "ParseRequestURI":
			return reflect.ValueOf(url.ParseRequestURI)
		case "PathEscape":
			return reflect.ValueOf(url.PathEscape)
		case "PathUnescape":
			return reflect.ValueOf(url.PathUnescape)
		case "QueryEscape":
			return reflect.ValueOf(url.QueryEscape)
		case "QueryUnescape":
			return reflect.ValueOf(url.QueryUnescape)
		case "User":
			return reflect.ValueOf(url.User)
		case "UserPassword":
			return reflect.ValueOf(url.UserPassword)
		}
	case "os":
		switch topLevelName {
		case "Args":
			return reflect.ValueOf(&os.Args)
		case "Chdir":
			return reflect.ValueOf(os.Chdir)
		case "Chmod":
			return reflect.ValueOf(os.Chmod)
		case "Chown":
			return reflect.ValueOf(os.Chown)
		case "Chtimes":
			return reflect.ValueOf(os.Chtimes)
		case "Clearenv":
			return reflect.ValueOf(os.Clearenv)
		case "Create":
			return reflect.ValueOf(os.Create)
		case "CreateTemp":
			return reflect.ValueOf(os.CreateTemp)
		case "DirFS":
			return reflect.ValueOf(os.DirFS)
		case "Environ":
			return reflect.ValueOf(os.Environ)
		case "ErrClosed":
			return reflect.ValueOf(&os.ErrClosed)
		case "ErrDeadlineExceeded":
			return reflect.ValueOf(&os.ErrDeadlineExceeded)
		case "ErrExist":
			return reflect.ValueOf(&os.ErrExist)
		case "ErrInvalid":
			return reflect.ValueOf(&os.ErrInvalid)
		case "ErrNoDeadline":
			return reflect.ValueOf(&os.ErrNoDeadline)
		case "ErrNotExist":
			return reflect.ValueOf(&os.ErrNotExist)
		case "ErrPermission":
			return reflect.ValueOf(&os.ErrPermission)
		case "ErrProcessDone":
			return reflect.ValueOf(&os.ErrProcessDone)
		case "Executable":
			return reflect.ValueOf(os.Executable)
		case "Exit":
			return reflect.ValueOf(os.Exit)
		case "Expand":
			return reflect.ValueOf(os.Expand)
		case "ExpandEnv":
			return reflect.ValueOf(os.ExpandEnv)
		case "FindProcess":
			return reflect.ValueOf(os.FindProcess)
		case "Getegid":
			return reflect.ValueOf(os.Getegid)
		case "Getenv":
			return reflect.ValueOf(os.Getenv)
		case "Geteuid":
			return reflect.ValueOf(os.Geteuid)
		case "Getgid":
			return reflect.ValueOf(os.Getgid)
		case "Getgroups":
			return reflect.ValueOf(os.Getgroups)
		case "Getpagesize":
			return reflect.ValueOf(os.Getpagesize)
		case "Getpid":
			return reflect.ValueOf(os.Getpid)
		case "Getppid":
			return reflect.ValueOf(os.Getppid)
		case "Getuid":
			return reflect.ValueOf(os.Getuid)
		case "Getwd":
			return reflect.ValueOf(os.Getwd)
		case "Hostname":
			return reflect.ValueOf(os.Hostname)
		case "Interrupt":
			return reflect.ValueOf(&os.Interrupt)
		case "IsExist":
			return reflect.ValueOf(os.IsExist)
		case "IsNotExist":
			return reflect.ValueOf(os.IsNotExist)
		case "IsPathSeparator":
			return reflect.ValueOf(os.IsPathSeparator)
		case "IsPermission":
			return reflect.ValueOf(os.IsPermission)
		case "IsTimeout":
			return reflect.ValueOf(os.IsTimeout)
		case "Kill":
			return reflect.ValueOf(&os.Kill)
		case "Lchown":
			return reflect.ValueOf(os.Lchown)
		case "Link":
			return reflect.ValueOf(os.Link)
		case "LookupEnv":
			return reflect.ValueOf(os.LookupEnv)
		case "Lstat":
			return reflect.ValueOf(os.Lstat)
		case "Mkdir":
			return reflect.ValueOf(os.Mkdir)
		case "MkdirAll":
			return reflect.ValueOf(os.MkdirAll)
		case "MkdirTemp":
			return reflect.ValueOf(os.MkdirTemp)
		case "NewFile":
			return reflect.ValueOf(os.NewFile)
		case "NewSyscallError":
			return reflect.ValueOf(os.NewSyscallError)
		case "Open":
			return reflect.ValueOf(os.Open)
		case "OpenFile":
			return reflect.ValueOf(os.OpenFile)
		case "Pipe":
			return reflect.ValueOf(os.Pipe)
		case "ReadDir":
			return reflect.ValueOf(os.ReadDir)
		case "ReadFile":
			return reflect.ValueOf(os.ReadFile)
		case "Readlink":
			return reflect.ValueOf(os.Readlink)
		case "Remove":
			return reflect.ValueOf(os.Remove)
		case "RemoveAll":
			return reflect.ValueOf(os.RemoveAll)
		case "Rename":
			return reflect.ValueOf(os.Rename)
		case "SameFile":
			return reflect.ValueOf(os.SameFile)
		case "Setenv":
			return reflect.ValueOf(os.Setenv)
		case "StartProcess":
			return reflect.ValueOf(os.StartProcess)
		case "Stat":
			return reflect.ValueOf(os.Stat)
		case "Stderr":
			return reflect.ValueOf(&os.Stderr)
		case "Stdin":
			return reflect.ValueOf(&os.Stdin)
		case "Stdout":
			return reflect.ValueOf(&os.Stdout)
		case "Symlink":
			return reflect.ValueOf(os.Symlink)
		case "TempDir":
			return reflect.ValueOf(os.TempDir)
		case "Truncate":
			return reflect.ValueOf(os.Truncate)
		case "Unsetenv":
			return reflect.ValueOf(os.Unsetenv)
		case "UserCacheDir":
			return reflect.ValueOf(os.UserCacheDir)
		case "UserConfigDir":
			return reflect.ValueOf(os.UserConfigDir)
		case "UserHomeDir":
			return reflect.ValueOf(os.UserHomeDir)
		case "WriteFile":
			return reflect.ValueOf(os.WriteFile)
		}
	case "os/exec":
		switch topLevelName {
		case "Command":
			return reflect.ValueOf(exec.Command)
		case "CommandContext":
			return reflect.ValueOf(exec.CommandContext)
		case "ErrNotFound":
			return reflect.ValueOf(&exec.ErrNotFound)
		case "LookPath":
			return reflect.ValueOf(exec.LookPath)
		}
	case "os/signal":
		switch topLevelName {
		case "Ignore":
			return reflect.ValueOf(signal.Ignore)
		case "Ignored":
			return reflect.ValueOf(signal.Ignored)
		case "Notify":
			return reflect.ValueOf(signal.Notify)
		case "NotifyContext":
			return reflect.ValueOf(signal.NotifyContext)
		case "Reset":
			return reflect.ValueOf(signal.Reset)
		case "Stop":
			return reflect.ValueOf(signal.Stop)
		}
	case "os/user":
		switch topLevelName {
		case "Current":
			return reflect.ValueOf(user.Current)
		case "Lookup":
			return reflect.ValueOf(user.Lookup)
		case "LookupGroup":
			return reflect.ValueOf(user.LookupGroup)
		case "LookupGroupId":
			return reflect.ValueOf(user.LookupGroupId)
		case "LookupId":
			return reflect.ValueOf(user.LookupId)
		}
	case "path":
		switch topLevelName {
		case "Base":
			return reflect.ValueOf(path.Base)
		case "Clean":
			return reflect.ValueOf(path.Clean)
		case "Dir":
			return reflect.ValueOf(path.Dir)
		case "ErrBadPattern":
			return reflect.ValueOf(&path.ErrBadPattern)
		case "Ext":
			return reflect.ValueOf(path.Ext)
		case "IsAbs":
			return reflect.ValueOf(path.IsAbs)
		case "Join":
			return reflect.ValueOf(path.Join)
		case "Match":
			return reflect.ValueOf(path.Match)
		case "Split":
			return reflect.ValueOf(path.Split)
		}
	case "path/filepath":
		switch topLevelName {
		case "Abs":
			return reflect.ValueOf(filepath.Abs)
		case "Base":
			return reflect.ValueOf(filepath.Base)
		case "Clean":
			return reflect.ValueOf(filepath.Clean)
		case "Dir":
			return reflect.ValueOf(filepath.Dir)
		case "ErrBadPattern":
			return reflect.ValueOf(&filepath.ErrBadPattern)
		case "EvalSymlinks":
			return reflect.ValueOf(filepath.EvalSymlinks)
		case "Ext":
			return reflect.ValueOf(filepath.Ext)
		case "FromSlash":
			return reflect.ValueOf(filepath.FromSlash)
		case "Glob":
			return reflect.ValueOf(filepath.Glob)
		case "HasPrefix":
			return reflect.ValueOf(filepath.HasPrefix)
		case "IsAbs":
			return reflect.ValueOf(filepath.IsAbs)
		case "Join":
			return reflect.ValueOf(filepath.Join)
		case "Match":
			return reflect.ValueOf(filepath.Match)
		case "Rel":
			return reflect.ValueOf(filepath.Rel)
		case "SkipDir":
			return reflect.ValueOf(&filepath.SkipDir)
		case "Split":
			return reflect.ValueOf(filepath.Split)
		case "SplitList":
			return reflect.ValueOf(filepath.SplitList)
		case "ToSlash":
			return reflect.ValueOf(filepath.ToSlash)
		case "VolumeName":
			return reflect.ValueOf(filepath.VolumeName)
		case "Walk":
			return reflect.ValueOf(filepath.Walk)
		case "WalkDir":
			return reflect.ValueOf(filepath.WalkDir)
		}
	case "plugin":
		switch topLevelName {
		case "Open":
			return reflect.ValueOf(plugin.Open)
		}
	case "reflect":
		switch topLevelName {
		case "Append":
			return reflect.ValueOf(reflect.Append)
		case "AppendSlice":
			return reflect.ValueOf(reflect.AppendSlice)
		case "ArrayOf":
			return reflect.ValueOf(reflect.ArrayOf)
		case "ChanOf":
			return reflect.ValueOf(reflect.ChanOf)
		case "Copy":
			return reflect.ValueOf(reflect.Copy)
		case "DeepEqual":
			return reflect.ValueOf(reflect.DeepEqual)
		case "FuncOf":
			return reflect.ValueOf(reflect.FuncOf)
		case "Indirect":
			return reflect.ValueOf(reflect.Indirect)
		case "MakeChan":
			return reflect.ValueOf(reflect.MakeChan)
		case "MakeFunc":
			return reflect.ValueOf(reflect.MakeFunc)
		case "MakeMap":
			return reflect.ValueOf(reflect.MakeMap)
		case "MakeMapWithSize":
			return reflect.ValueOf(reflect.MakeMapWithSize)
		case "MakeSlice":
			return reflect.ValueOf(reflect.MakeSlice)
		case "MapOf":
			return reflect.ValueOf(reflect.MapOf)
		case "New":
			return reflect.ValueOf(reflect.New)
		case "NewAt":
			return reflect.ValueOf(reflect.NewAt)
		case "PointerTo":
			return reflect.ValueOf(reflect.PointerTo)
		case "PtrTo":
			return reflect.ValueOf(reflect.PtrTo)
		case "Select":
			return reflect.ValueOf(reflect.Select)
		case "SliceOf":
			return reflect.ValueOf(reflect.SliceOf)
		case "StructOf":
			return reflect.ValueOf(reflect.StructOf)
		case "Swapper":
			return reflect.ValueOf(reflect.Swapper)
		case "TypeOf":
			return reflect.ValueOf(reflect.TypeOf)
		case "ValueOf":
			return reflect.ValueOf(reflect.ValueOf)
		case "VisibleFields":
			return reflect.ValueOf(reflect.VisibleFields)
		case "Zero":
			return reflect.ValueOf(reflect.Zero)
		}
	case "regexp":
		switch topLevelName {
		case "Compile":
			return reflect.ValueOf(regexp.Compile)
		case "CompilePOSIX":
			return reflect.ValueOf(regexp.CompilePOSIX)
		case "Match":
			return reflect.ValueOf(regexp.Match)
		case "MatchReader":
			return reflect.ValueOf(regexp.MatchReader)
		case "MatchString":
			return reflect.ValueOf(regexp.MatchString)
		case "MustCompile":
			return reflect.ValueOf(regexp.MustCompile)
		case "MustCompilePOSIX":
			return reflect.ValueOf(regexp.MustCompilePOSIX)
		case "QuoteMeta":
			return reflect.ValueOf(regexp.QuoteMeta)
		}
	case "regexp/syntax":
		switch topLevelName {
		case "Compile":
			return reflect.ValueOf(syntax.Compile)
		case "EmptyOpContext":
			return reflect.ValueOf(syntax.EmptyOpContext)
		case "IsWordChar":
			return reflect.ValueOf(syntax.IsWordChar)
		case "Parse":
			return reflect.ValueOf(syntax.Parse)
		}
	case "runtime":
		switch topLevelName {
		case "BlockProfile":
			return reflect.ValueOf(runtime.BlockProfile)
		case "Breakpoint":
			return reflect.ValueOf(runtime.Breakpoint)
		case "CPUProfile":
			return reflect.ValueOf(runtime.CPUProfile)
		case "Caller":
			return reflect.ValueOf(runtime.Caller)
		case "Callers":
			return reflect.ValueOf(runtime.Callers)
		case "CallersFrames":
			return reflect.ValueOf(runtime.CallersFrames)
		case "FuncForPC":
			return reflect.ValueOf(runtime.FuncForPC)
		case "GC":
			return reflect.ValueOf(runtime.GC)
		case "GOMAXPROCS":
			return reflect.ValueOf(runtime.GOMAXPROCS)
		case "GOROOT":
			return reflect.ValueOf(runtime.GOROOT)
		case "Goexit":
			return reflect.ValueOf(runtime.Goexit)
		case "GoroutineProfile":
			return reflect.ValueOf(runtime.GoroutineProfile)
		case "Gosched":
			return reflect.ValueOf(runtime.Gosched)
		case "KeepAlive":
			return reflect.ValueOf(runtime.KeepAlive)
		case "LockOSThread":
			return reflect.ValueOf(runtime.LockOSThread)
		case "MemProfile":
			return reflect.ValueOf(runtime.MemProfile)
		case "MemProfileRate":
			return reflect.ValueOf(&runtime.MemProfileRate)
		case "MutexProfile":
			return reflect.ValueOf(runtime.MutexProfile)
		case "NumCPU":
			return reflect.ValueOf(runtime.NumCPU)
		case "NumCgoCall":
			return reflect.ValueOf(runtime.NumCgoCall)
		case "NumGoroutine":
			return reflect.ValueOf(runtime.NumGoroutine)
		case "ReadMemStats":
			return reflect.ValueOf(runtime.ReadMemStats)
		case "ReadTrace":
			return reflect.ValueOf(runtime.ReadTrace)
		case "SetBlockProfileRate":
			return reflect.ValueOf(runtime.SetBlockProfileRate)
		case "SetCPUProfileRate":
			return reflect.ValueOf(runtime.SetCPUProfileRate)
		case "SetCgoTraceback":
			return reflect.ValueOf(runtime.SetCgoTraceback)
		case "SetFinalizer":
			return reflect.ValueOf(runtime.SetFinalizer)
		case "SetMutexProfileFraction":
			return reflect.ValueOf(runtime.SetMutexProfileFraction)
		case "Stack":
			return reflect.ValueOf(runtime.Stack)
		case "StartTrace":
			return reflect.ValueOf(runtime.StartTrace)
		case "StopTrace":
			return reflect.ValueOf(runtime.StopTrace)
		case "ThreadCreateProfile":
			return reflect.ValueOf(runtime.ThreadCreateProfile)
		case "UnlockOSThread":
			return reflect.ValueOf(runtime.UnlockOSThread)
		case "Version":
			return reflect.ValueOf(runtime.Version)
		}
	case "runtime/debug":
		switch topLevelName {
		case "FreeOSMemory":
			return reflect.ValueOf(debug.FreeOSMemory)
		case "ParseBuildInfo":
			return reflect.ValueOf(debug.ParseBuildInfo)
		case "PrintStack":
			return reflect.ValueOf(debug.PrintStack)
		case "ReadBuildInfo":
			return reflect.ValueOf(debug.ReadBuildInfo)
		case "ReadGCStats":
			return reflect.ValueOf(debug.ReadGCStats)
		case "SetGCPercent":
			return reflect.ValueOf(debug.SetGCPercent)
		case "SetMaxStack":
			return reflect.ValueOf(debug.SetMaxStack)
		case "SetMaxThreads":
			return reflect.ValueOf(debug.SetMaxThreads)
		case "SetPanicOnFault":
			return reflect.ValueOf(debug.SetPanicOnFault)
		case "SetTraceback":
			return reflect.ValueOf(debug.SetTraceback)
		case "Stack":
			return reflect.ValueOf(debug.Stack)
		case "WriteHeapDump":
			return reflect.ValueOf(debug.WriteHeapDump)
		}
	case "runtime/metrics":
		switch topLevelName {
		case "All":
			return reflect.ValueOf(metrics.All)
		case "Read":
			return reflect.ValueOf(metrics.Read)
		}
	case "runtime/pprof":
		switch topLevelName {
		case "Do":
			return reflect.ValueOf(pprof1.Do)
		case "ForLabels":
			return reflect.ValueOf(pprof1.ForLabels)
		case "Label":
			return reflect.ValueOf(pprof1.Label)
		case "Labels":
			return reflect.ValueOf(pprof1.Labels)
		case "Lookup":
			return reflect.ValueOf(pprof1.Lookup)
		case "NewProfile":
			return reflect.ValueOf(pprof1.NewProfile)
		case "Profiles":
			return reflect.ValueOf(pprof1.Profiles)
		case "SetGoroutineLabels":
			return reflect.ValueOf(pprof1.SetGoroutineLabels)
		case "StartCPUProfile":
			return reflect.ValueOf(pprof1.StartCPUProfile)
		case "StopCPUProfile":
			return reflect.ValueOf(pprof1.StopCPUProfile)
		case "WithLabels":
			return reflect.ValueOf(pprof1.WithLabels)
		case "WriteHeapProfile":
			return reflect.ValueOf(pprof1.WriteHeapProfile)
		}
	case "runtime/trace":
		switch topLevelName {
		case "IsEnabled":
			return reflect.ValueOf(trace.IsEnabled)
		case "Log":
			return reflect.ValueOf(trace.Log)
		case "Logf":
			return reflect.ValueOf(trace.Logf)
		case "NewTask":
			return reflect.ValueOf(trace.NewTask)
		case "Start":
			return reflect.ValueOf(trace.Start)
		case "StartRegion":
			return reflect.ValueOf(trace.StartRegion)
		case "Stop":
			return reflect.ValueOf(trace.Stop)
		case "WithRegion":
			return reflect.ValueOf(trace.WithRegion)
		}
	case "sort":
		switch topLevelName {
		case "Float64s":
			return reflect.ValueOf(sort.Float64s)
		case "Float64sAreSorted":
			return reflect.ValueOf(sort.Float64sAreSorted)
		case "Ints":
			return reflect.ValueOf(sort.Ints)
		case "IntsAreSorted":
			return reflect.ValueOf(sort.IntsAreSorted)
		case "IsSorted":
			return reflect.ValueOf(sort.IsSorted)
		case "Reverse":
			return reflect.ValueOf(sort.Reverse)
		case "Search":
			return reflect.ValueOf(sort.Search)
		case "SearchFloat64s":
			return reflect.ValueOf(sort.SearchFloat64s)
		case "SearchInts":
			return reflect.ValueOf(sort.SearchInts)
		case "SearchStrings":
			return reflect.ValueOf(sort.SearchStrings)
		case "Slice":
			return reflect.ValueOf(sort.Slice)
		case "SliceIsSorted":
			return reflect.ValueOf(sort.SliceIsSorted)
		case "SliceStable":
			return reflect.ValueOf(sort.SliceStable)
		case "Sort":
			return reflect.ValueOf(sort.Sort)
		case "Stable":
			return reflect.ValueOf(sort.Stable)
		case "Strings":
			return reflect.ValueOf(sort.Strings)
		case "StringsAreSorted":
			return reflect.ValueOf(sort.StringsAreSorted)
		}
	case "strconv":
		switch topLevelName {
		case "AppendBool":
			return reflect.ValueOf(strconv.AppendBool)
		case "AppendFloat":
			return reflect.ValueOf(strconv.AppendFloat)
		case "AppendInt":
			return reflect.ValueOf(strconv.AppendInt)
		case "AppendQuote":
			return reflect.ValueOf(strconv.AppendQuote)
		case "AppendQuoteRune":
			return reflect.ValueOf(strconv.AppendQuoteRune)
		case "AppendQuoteRuneToASCII":
			return reflect.ValueOf(strconv.AppendQuoteRuneToASCII)
		case "AppendQuoteRuneToGraphic":
			return reflect.ValueOf(strconv.AppendQuoteRuneToGraphic)
		case "AppendQuoteToASCII":
			return reflect.ValueOf(strconv.AppendQuoteToASCII)
		case "AppendQuoteToGraphic":
			return reflect.ValueOf(strconv.AppendQuoteToGraphic)
		case "AppendUint":
			return reflect.ValueOf(strconv.AppendUint)
		case "Atoi":
			return reflect.ValueOf(strconv.Atoi)
		case "CanBackquote":
			return reflect.ValueOf(strconv.CanBackquote)
		case "ErrRange":
			return reflect.ValueOf(&strconv.ErrRange)
		case "ErrSyntax":
			return reflect.ValueOf(&strconv.ErrSyntax)
		case "FormatBool":
			return reflect.ValueOf(strconv.FormatBool)
		case "FormatComplex":
			return reflect.ValueOf(strconv.FormatComplex)
		case "FormatFloat":
			return reflect.ValueOf(strconv.FormatFloat)
		case "FormatInt":
			return reflect.ValueOf(strconv.FormatInt)
		case "FormatUint":
			return reflect.ValueOf(strconv.FormatUint)
		case "IsGraphic":
			return reflect.ValueOf(strconv.IsGraphic)
		case "IsPrint":
			return reflect.ValueOf(strconv.IsPrint)
		case "Itoa":
			return reflect.ValueOf(strconv.Itoa)
		case "ParseBool":
			return reflect.ValueOf(strconv.ParseBool)
		case "ParseComplex":
			return reflect.ValueOf(strconv.ParseComplex)
		case "ParseFloat":
			return reflect.ValueOf(strconv.ParseFloat)
		case "ParseInt":
			return reflect.ValueOf(strconv.ParseInt)
		case "ParseUint":
			return reflect.ValueOf(strconv.ParseUint)
		case "Quote":
			return reflect.ValueOf(strconv.Quote)
		case "QuoteRune":
			return reflect.ValueOf(strconv.QuoteRune)
		case "QuoteRuneToASCII":
			return reflect.ValueOf(strconv.QuoteRuneToASCII)
		case "QuoteRuneToGraphic":
			return reflect.ValueOf(strconv.QuoteRuneToGraphic)
		case "QuoteToASCII":
			return reflect.ValueOf(strconv.QuoteToASCII)
		case "QuoteToGraphic":
			return reflect.ValueOf(strconv.QuoteToGraphic)
		case "QuotedPrefix":
			return reflect.ValueOf(strconv.QuotedPrefix)
		case "Unquote":
			return reflect.ValueOf(strconv.Unquote)
		case "UnquoteChar":
			return reflect.ValueOf(strconv.UnquoteChar)
		}
	case "strings":
		switch topLevelName {
		case "Clone":
			return reflect.ValueOf(strings.Clone)
		case "Compare":
			return reflect.ValueOf(strings.Compare)
		case "Contains":
			return reflect.ValueOf(strings.Contains)
		case "ContainsAny":
			return reflect.ValueOf(strings.ContainsAny)
		case "ContainsRune":
			return reflect.ValueOf(strings.ContainsRune)
		case "Count":
			return reflect.ValueOf(strings.Count)
		case "Cut":
			return reflect.ValueOf(strings.Cut)
		case "EqualFold":
			return reflect.ValueOf(strings.EqualFold)
		case "Fields":
			return reflect.ValueOf(strings.Fields)
		case "FieldsFunc":
			return reflect.ValueOf(strings.FieldsFunc)
		case "HasPrefix":
			return reflect.ValueOf(strings.HasPrefix)
		case "HasSuffix":
			return reflect.ValueOf(strings.HasSuffix)
		case "Index":
			return reflect.ValueOf(strings.Index)
		case "IndexAny":
			return reflect.ValueOf(strings.IndexAny)
		case "IndexByte":
			return reflect.ValueOf(strings.IndexByte)
		case "IndexFunc":
			return reflect.ValueOf(strings.IndexFunc)
		case "IndexRune":
			return reflect.ValueOf(strings.IndexRune)
		case "Join":
			return reflect.ValueOf(strings.Join)
		case "LastIndex":
			return reflect.ValueOf(strings.LastIndex)
		case "LastIndexAny":
			return reflect.ValueOf(strings.LastIndexAny)
		case "LastIndexByte":
			return reflect.ValueOf(strings.LastIndexByte)
		case "LastIndexFunc":
			return reflect.ValueOf(strings.LastIndexFunc)
		case "Map":
			return reflect.ValueOf(strings.Map)
		case "NewReader":
			return reflect.ValueOf(strings.NewReader)
		case "NewReplacer":
			return reflect.ValueOf(strings.NewReplacer)
		case "Repeat":
			return reflect.ValueOf(strings.Repeat)
		case "Replace":
			return reflect.ValueOf(strings.Replace)
		case "ReplaceAll":
			return reflect.ValueOf(strings.ReplaceAll)
		case "Split":
			return reflect.ValueOf(strings.Split)
		case "SplitAfter":
			return reflect.ValueOf(strings.SplitAfter)
		case "SplitAfterN":
			return reflect.ValueOf(strings.SplitAfterN)
		case "SplitN":
			return reflect.ValueOf(strings.SplitN)
		case "Title":
			return reflect.ValueOf(strings.Title)
		case "ToLower":
			return reflect.ValueOf(strings.ToLower)
		case "ToLowerSpecial":
			return reflect.ValueOf(strings.ToLowerSpecial)
		case "ToTitle":
			return reflect.ValueOf(strings.ToTitle)
		case "ToTitleSpecial":
			return reflect.ValueOf(strings.ToTitleSpecial)
		case "ToUpper":
			return reflect.ValueOf(strings.ToUpper)
		case "ToUpperSpecial":
			return reflect.ValueOf(strings.ToUpperSpecial)
		case "ToValidUTF8":
			return reflect.ValueOf(strings.ToValidUTF8)
		case "Trim":
			return reflect.ValueOf(strings.Trim)
		case "TrimFunc":
			return reflect.ValueOf(strings.TrimFunc)
		case "TrimLeft":
			return reflect.ValueOf(strings.TrimLeft)
		case "TrimLeftFunc":
			return reflect.ValueOf(strings.TrimLeftFunc)
		case "TrimPrefix":
			return reflect.ValueOf(strings.TrimPrefix)
		case "TrimRight":
			return reflect.ValueOf(strings.TrimRight)
		case "TrimRightFunc":
			return reflect.ValueOf(strings.TrimRightFunc)
		case "TrimSpace":
			return reflect.ValueOf(strings.TrimSpace)
		case "TrimSuffix":
			return reflect.ValueOf(strings.TrimSuffix)
		}
	case "sync":
		switch topLevelName {
		case "NewCond":
			return reflect.ValueOf(sync.NewCond)
		}
	case "sync/atomic":
		switch topLevelName {
		case "AddInt32":
			return reflect.ValueOf(atomic.AddInt32)
		case "AddInt64":
			return reflect.ValueOf(atomic.AddInt64)
		case "AddUint32":
			return reflect.ValueOf(atomic.AddUint32)
		case "AddUint64":
			return reflect.ValueOf(atomic.AddUint64)
		case "AddUintptr":
			return reflect.ValueOf(atomic.AddUintptr)
		case "CompareAndSwapInt32":
			return reflect.ValueOf(atomic.CompareAndSwapInt32)
		case "CompareAndSwapInt64":
			return reflect.ValueOf(atomic.CompareAndSwapInt64)
		case "CompareAndSwapPointer":
			return reflect.ValueOf(atomic.CompareAndSwapPointer)
		case "CompareAndSwapUint32":
			return reflect.ValueOf(atomic.CompareAndSwapUint32)
		case "CompareAndSwapUint64":
			return reflect.ValueOf(atomic.CompareAndSwapUint64)
		case "CompareAndSwapUintptr":
			return reflect.ValueOf(atomic.CompareAndSwapUintptr)
		case "LoadInt32":
			return reflect.ValueOf(atomic.LoadInt32)
		case "LoadInt64":
			return reflect.ValueOf(atomic.LoadInt64)
		case "LoadPointer":
			return reflect.ValueOf(atomic.LoadPointer)
		case "LoadUint32":
			return reflect.ValueOf(atomic.LoadUint32)
		case "LoadUint64":
			return reflect.ValueOf(atomic.LoadUint64)
		case "LoadUintptr":
			return reflect.ValueOf(atomic.LoadUintptr)
		case "StoreInt32":
			return reflect.ValueOf(atomic.StoreInt32)
		case "StoreInt64":
			return reflect.ValueOf(atomic.StoreInt64)
		case "StorePointer":
			return reflect.ValueOf(atomic.StorePointer)
		case "StoreUint32":
			return reflect.ValueOf(atomic.StoreUint32)
		case "StoreUint64":
			return reflect.ValueOf(atomic.StoreUint64)
		case "StoreUintptr":
			return reflect.ValueOf(atomic.StoreUintptr)
		case "SwapInt32":
			return reflect.ValueOf(atomic.SwapInt32)
		case "SwapInt64":
			return reflect.ValueOf(atomic.SwapInt64)
		case "SwapPointer":
			return reflect.ValueOf(atomic.SwapPointer)
		case "SwapUint32":
			return reflect.ValueOf(atomic.SwapUint32)
		case "SwapUint64":
			return reflect.ValueOf(atomic.SwapUint64)
		case "SwapUintptr":
			return reflect.ValueOf(atomic.SwapUintptr)
		}
	case "testing":
		switch topLevelName {
		case "AllocsPerRun":
			return reflect.ValueOf(testing.AllocsPerRun)
		case "Benchmark":
			return reflect.ValueOf(testing.Benchmark)
		case "CoverMode":
			return reflect.ValueOf(testing.CoverMode)
		case "Coverage":
			return reflect.ValueOf(testing.Coverage)
		case "Init":
			return reflect.ValueOf(testing.Init)
		case "Main":
			return reflect.ValueOf(testing.Main)
		case "MainStart":
			return reflect.ValueOf(testing.MainStart)
		case "RegisterCover":
			return reflect.ValueOf(testing.RegisterCover)
		case "RunBenchmarks":
			return reflect.ValueOf(testing.RunBenchmarks)
		case "RunExamples":
			return reflect.ValueOf(testing.RunExamples)
		case "RunTests":
			return reflect.ValueOf(testing.RunTests)
		case "Short":
			return reflect.ValueOf(testing.Short)
		case "Verbose":
			return reflect.ValueOf(testing.Verbose)
		}
	case "testing/fstest":
		switch topLevelName {
		case "TestFS":
			return reflect.ValueOf(fstest.TestFS)
		}
	case "testing/iotest":
		switch topLevelName {
		case "DataErrReader":
			return reflect.ValueOf(iotest.DataErrReader)
		case "ErrReader":
			return reflect.ValueOf(iotest.ErrReader)
		case "ErrTimeout":
			return reflect.ValueOf(&iotest.ErrTimeout)
		case "HalfReader":
			return reflect.ValueOf(iotest.HalfReader)
		case "NewReadLogger":
			return reflect.ValueOf(iotest.NewReadLogger)
		case "NewWriteLogger":
			return reflect.ValueOf(iotest.NewWriteLogger)
		case "OneByteReader":
			return reflect.ValueOf(iotest.OneByteReader)
		case "TestReader":
			return reflect.ValueOf(iotest.TestReader)
		case "TimeoutReader":
			return reflect.ValueOf(iotest.TimeoutReader)
		case "TruncateWriter":
			return reflect.ValueOf(iotest.TruncateWriter)
		}
	case "testing/quick":
		switch topLevelName {
		case "Check":
			return reflect.ValueOf(quick.Check)
		case "CheckEqual":
			return reflect.ValueOf(quick.CheckEqual)
		case "Value":
			return reflect.ValueOf(quick.Value)
		}
	case "text/scanner":
		switch topLevelName {
		case "TokenString":
			return reflect.ValueOf(scanner1.TokenString)
		}
	case "text/tabwriter":
		switch topLevelName {
		case "NewWriter":
			return reflect.ValueOf(tabwriter.NewWriter)
		}
	case "text/template":
		switch topLevelName {
		case "HTMLEscape":
			return reflect.ValueOf(template1.HTMLEscape)
		case "HTMLEscapeString":
			return reflect.ValueOf(template1.HTMLEscapeString)
		case "HTMLEscaper":
			return reflect.ValueOf(template1.HTMLEscaper)
		case "IsTrue":
			return reflect.ValueOf(template1.IsTrue)
		case "JSEscape":
			return reflect.ValueOf(template1.JSEscape)
		case "JSEscapeString":
			return reflect.ValueOf(template1.JSEscapeString)
		case "JSEscaper":
			return reflect.ValueOf(template1.JSEscaper)
		case "Must":
			return reflect.ValueOf(template1.Must)
		case "New":
			return reflect.ValueOf(template1.New)
		case "ParseFS":
			return reflect.ValueOf(template1.ParseFS)
		case "ParseFiles":
			return reflect.ValueOf(template1.ParseFiles)
		case "ParseGlob":
			return reflect.ValueOf(template1.ParseGlob)
		case "URLQueryEscaper":
			return reflect.ValueOf(template1.URLQueryEscaper)
		}
	case "text/template/parse":
		switch topLevelName {
		case "IsEmptyTree":
			return reflect.ValueOf(parse.IsEmptyTree)
		case "New":
			return reflect.ValueOf(parse.New)
		case "NewIdentifier":
			return reflect.ValueOf(parse.NewIdentifier)
		case "Parse":
			return reflect.ValueOf(parse.Parse)
		}
	case "time":
		switch topLevelName {
		case "After":
			return reflect.ValueOf(time.After)
		case "AfterFunc":
			return reflect.ValueOf(time.AfterFunc)
		case "Date":
			return reflect.ValueOf(time.Date)
		case "FixedZone":
			return reflect.ValueOf(time.FixedZone)
		case "LoadLocation":
			return reflect.ValueOf(time.LoadLocation)
		case "LoadLocationFromTZData":
			return reflect.ValueOf(time.LoadLocationFromTZData)
		case "Local":
			return reflect.ValueOf(&time.Local)
		case "NewTicker":
			return reflect.ValueOf(time.NewTicker)
		case "NewTimer":
			return reflect.ValueOf(time.NewTimer)
		case "Now":
			return reflect.ValueOf(time.Now)
		case "Parse":
			return reflect.ValueOf(time.Parse)
		case "ParseDuration":
			return reflect.ValueOf(time.ParseDuration)
		case "ParseInLocation":
			return reflect.ValueOf(time.ParseInLocation)
		case "Since":
			return reflect.ValueOf(time.Since)
		case "Sleep":
			return reflect.ValueOf(time.Sleep)
		case "Tick":
			return reflect.ValueOf(time.Tick)
		case "UTC":
			return reflect.ValueOf(&time.UTC)
		case "Unix":
			return reflect.ValueOf(time.Unix)
		case "UnixMicro":
			return reflect.ValueOf(time.UnixMicro)
		case "UnixMilli":
			return reflect.ValueOf(time.UnixMilli)
		case "Until":
			return reflect.ValueOf(time.Until)
		}
	case "unicode":
		switch topLevelName {
		case "ASCII_Hex_Digit":
			return reflect.ValueOf(&unicode.ASCII_Hex_Digit)
		case "Adlam":
			return reflect.ValueOf(&unicode.Adlam)
		case "Ahom":
			return reflect.ValueOf(&unicode.Ahom)
		case "Anatolian_Hieroglyphs":
			return reflect.ValueOf(&unicode.Anatolian_Hieroglyphs)
		case "Arabic":
			return reflect.ValueOf(&unicode.Arabic)
		case "Armenian":
			return reflect.ValueOf(&unicode.Armenian)
		case "Avestan":
			return reflect.ValueOf(&unicode.Avestan)
		case "AzeriCase":
			return reflect.ValueOf(&unicode.AzeriCase)
		case "Balinese":
			return reflect.ValueOf(&unicode.Balinese)
		case "Bamum":
			return reflect.ValueOf(&unicode.Bamum)
		case "Bassa_Vah":
			return reflect.ValueOf(&unicode.Bassa_Vah)
		case "Batak":
			return reflect.ValueOf(&unicode.Batak)
		case "Bengali":
			return reflect.ValueOf(&unicode.Bengali)
		case "Bhaiksuki":
			return reflect.ValueOf(&unicode.Bhaiksuki)
		case "Bidi_Control":
			return reflect.ValueOf(&unicode.Bidi_Control)
		case "Bopomofo":
			return reflect.ValueOf(&unicode.Bopomofo)
		case "Brahmi":
			return reflect.ValueOf(&unicode.Brahmi)
		case "Braille":
			return reflect.ValueOf(&unicode.Braille)
		case "Buginese":
			return reflect.ValueOf(&unicode.Buginese)
		case "Buhid":
			return reflect.ValueOf(&unicode.Buhid)
		case "C":
			return reflect.ValueOf(&unicode.C)
		case "Canadian_Aboriginal":
			return reflect.ValueOf(&unicode.Canadian_Aboriginal)
		case "Carian":
			return reflect.ValueOf(&unicode.Carian)
		case "CaseRanges":
			return reflect.ValueOf(&unicode.CaseRanges)
		case "Categories":
			return reflect.ValueOf(&unicode.Categories)
		case "Caucasian_Albanian":
			return reflect.ValueOf(&unicode.Caucasian_Albanian)
		case "Cc":
			return reflect.ValueOf(&unicode.Cc)
		case "Cf":
			return reflect.ValueOf(&unicode.Cf)
		case "Chakma":
			return reflect.ValueOf(&unicode.Chakma)
		case "Cham":
			return reflect.ValueOf(&unicode.Cham)
		case "Cherokee":
			return reflect.ValueOf(&unicode.Cherokee)
		case "Chorasmian":
			return reflect.ValueOf(&unicode.Chorasmian)
		case "Co":
			return reflect.ValueOf(&unicode.Co)
		case "Common":
			return reflect.ValueOf(&unicode.Common)
		case "Coptic":
			return reflect.ValueOf(&unicode.Coptic)
		case "Cs":
			return reflect.ValueOf(&unicode.Cs)
		case "Cuneiform":
			return reflect.ValueOf(&unicode.Cuneiform)
		case "Cypriot":
			return reflect.ValueOf(&unicode.Cypriot)
		case "Cyrillic":
			return reflect.ValueOf(&unicode.Cyrillic)
		case "Dash":
			return reflect.ValueOf(&unicode.Dash)
		case "Deprecated":
			return reflect.ValueOf(&unicode.Deprecated)
		case "Deseret":
			return reflect.ValueOf(&unicode.Deseret)
		case "Devanagari":
			return reflect.ValueOf(&unicode.Devanagari)
		case "Diacritic":
			return reflect.ValueOf(&unicode.Diacritic)
		case "Digit":
			return reflect.ValueOf(&unicode.Digit)
		case "Dives_Akuru":
			return reflect.ValueOf(&unicode.Dives_Akuru)
		case "Dogra":
			return reflect.ValueOf(&unicode.Dogra)
		case "Duployan":
			return reflect.ValueOf(&unicode.Duployan)
		case "Egyptian_Hieroglyphs":
			return reflect.ValueOf(&unicode.Egyptian_Hieroglyphs)
		case "Elbasan":
			return reflect.ValueOf(&unicode.Elbasan)
		case "Elymaic":
			return reflect.ValueOf(&unicode.Elymaic)
		case "Ethiopic":
			return reflect.ValueOf(&unicode.Ethiopic)
		case "Extender":
			return reflect.ValueOf(&unicode.Extender)
		case "FoldCategory":
			return reflect.ValueOf(&unicode.FoldCategory)
		case "FoldScript":
			return reflect.ValueOf(&unicode.FoldScript)
		case "Georgian":
			return reflect.ValueOf(&unicode.Georgian)
		case "Glagolitic":
			return reflect.ValueOf(&unicode.Glagolitic)
		case "Gothic":
			return reflect.ValueOf(&unicode.Gothic)
		case "Grantha":
			return reflect.ValueOf(&unicode.Grantha)
		case "GraphicRanges":
			return reflect.ValueOf(&unicode.GraphicRanges)
		case "Greek":
			return reflect.ValueOf(&unicode.Greek)
		case "Gujarati":
			return reflect.ValueOf(&unicode.Gujarati)
		case "Gunjala_Gondi":
			return reflect.ValueOf(&unicode.Gunjala_Gondi)
		case "Gurmukhi":
			return reflect.ValueOf(&unicode.Gurmukhi)
		case "Han":
			return reflect.ValueOf(&unicode.Han)
		case "Hangul":
			return reflect.ValueOf(&unicode.Hangul)
		case "Hanifi_Rohingya":
			return reflect.ValueOf(&unicode.Hanifi_Rohingya)
		case "Hanunoo":
			return reflect.ValueOf(&unicode.Hanunoo)
		case "Hatran":
			return reflect.ValueOf(&unicode.Hatran)
		case "Hebrew":
			return reflect.ValueOf(&unicode.Hebrew)
		case "Hex_Digit":
			return reflect.ValueOf(&unicode.Hex_Digit)
		case "Hiragana":
			return reflect.ValueOf(&unicode.Hiragana)
		case "Hyphen":
			return reflect.ValueOf(&unicode.Hyphen)
		case "IDS_Binary_Operator":
			return reflect.ValueOf(&unicode.IDS_Binary_Operator)
		case "IDS_Trinary_Operator":
			return reflect.ValueOf(&unicode.IDS_Trinary_Operator)
		case "Ideographic":
			return reflect.ValueOf(&unicode.Ideographic)
		case "Imperial_Aramaic":
			return reflect.ValueOf(&unicode.Imperial_Aramaic)
		case "In":
			return reflect.ValueOf(unicode.In)
		case "Inherited":
			return reflect.ValueOf(&unicode.Inherited)
		case "Inscriptional_Pahlavi":
			return reflect.ValueOf(&unicode.Inscriptional_Pahlavi)
		case "Inscriptional_Parthian":
			return reflect.ValueOf(&unicode.Inscriptional_Parthian)
		case "Is":
			return reflect.ValueOf(unicode.Is)
		case "IsControl":
			return reflect.ValueOf(unicode.IsControl)
		case "IsDigit":
			return reflect.ValueOf(unicode.IsDigit)
		case "IsGraphic":
			return reflect.ValueOf(unicode.IsGraphic)
		case "IsLetter":
			return reflect.ValueOf(unicode.IsLetter)
		case "IsLower":
			return reflect.ValueOf(unicode.IsLower)
		case "IsMark":
			return reflect.ValueOf(unicode.IsMark)
		case "IsNumber":
			return reflect.ValueOf(unicode.IsNumber)
		case "IsOneOf":
			return reflect.ValueOf(unicode.IsOneOf)
		case "IsPrint":
			return reflect.ValueOf(unicode.IsPrint)
		case "IsPunct":
			return reflect.ValueOf(unicode.IsPunct)
		case "IsSpace":
			return reflect.ValueOf(unicode.IsSpace)
		case "IsSymbol":
			return reflect.ValueOf(unicode.IsSymbol)
		case "IsTitle":
			return reflect.ValueOf(unicode.IsTitle)
		case "IsUpper":
			return reflect.ValueOf(unicode.IsUpper)
		case "Javanese":
			return reflect.ValueOf(&unicode.Javanese)
		case "Join_Control":
			return reflect.ValueOf(&unicode.Join_Control)
		case "Kaithi":
			return reflect.ValueOf(&unicode.Kaithi)
		case "Kannada":
			return reflect.ValueOf(&unicode.Kannada)
		case "Katakana":
			return reflect.ValueOf(&unicode.Katakana)
		case "Kayah_Li":
			return reflect.ValueOf(&unicode.Kayah_Li)
		case "Kharoshthi":
			return reflect.ValueOf(&unicode.Kharoshthi)
		case "Khitan_Small_Script":
			return reflect.ValueOf(&unicode.Khitan_Small_Script)
		case "Khmer":
			return reflect.ValueOf(&unicode.Khmer)
		case "Khojki":
			return reflect.ValueOf(&unicode.Khojki)
		case "Khudawadi":
			return reflect.ValueOf(&unicode.Khudawadi)
		case "L":
			return reflect.ValueOf(&unicode.L)
		case "Lao":
			return reflect.ValueOf(&unicode.Lao)
		case "Latin":
			return reflect.ValueOf(&unicode.Latin)
		case "Lepcha":
			return reflect.ValueOf(&unicode.Lepcha)
		case "Letter":
			return reflect.ValueOf(&unicode.Letter)
		case "Limbu":
			return reflect.ValueOf(&unicode.Limbu)
		case "Linear_A":
			return reflect.ValueOf(&unicode.Linear_A)
		case "Linear_B":
			return reflect.ValueOf(&unicode.Linear_B)
		case "Lisu":
			return reflect.ValueOf(&unicode.Lisu)
		case "Ll":
			return reflect.ValueOf(&unicode.Ll)
		case "Lm":
			return reflect.ValueOf(&unicode.Lm)
		case "Lo":
			return reflect.ValueOf(&unicode.Lo)
		case "Logical_Order_Exception":
			return reflect.ValueOf(&unicode.Logical_Order_Exception)
		case "Lower":
			return reflect.ValueOf(&unicode.Lower)
		case "Lt":
			return reflect.ValueOf(&unicode.Lt)
		case "Lu":
			return reflect.ValueOf(&unicode.Lu)
		case "Lycian":
			return reflect.ValueOf(&unicode.Lycian)
		case "Lydian":
			return reflect.ValueOf(&unicode.Lydian)
		case "M":
			return reflect.ValueOf(&unicode.M)
		case "Mahajani":
			return reflect.ValueOf(&unicode.Mahajani)
		case "Makasar":
			return reflect.ValueOf(&unicode.Makasar)
		case "Malayalam":
			return reflect.ValueOf(&unicode.Malayalam)
		case "Mandaic":
			return reflect.ValueOf(&unicode.Mandaic)
		case "Manichaean":
			return reflect.ValueOf(&unicode.Manichaean)
		case "Marchen":
			return reflect.ValueOf(&unicode.Marchen)
		case "Mark":
			return reflect.ValueOf(&unicode.Mark)
		case "Masaram_Gondi":
			return reflect.ValueOf(&unicode.Masaram_Gondi)
		case "Mc":
			return reflect.ValueOf(&unicode.Mc)
		case "Me":
			return reflect.ValueOf(&unicode.Me)
		case "Medefaidrin":
			return reflect.ValueOf(&unicode.Medefaidrin)
		case "Meetei_Mayek":
			return reflect.ValueOf(&unicode.Meetei_Mayek)
		case "Mende_Kikakui":
			return reflect.ValueOf(&unicode.Mende_Kikakui)
		case "Meroitic_Cursive":
			return reflect.ValueOf(&unicode.Meroitic_Cursive)
		case "Meroitic_Hieroglyphs":
			return reflect.ValueOf(&unicode.Meroitic_Hieroglyphs)
		case "Miao":
			return reflect.ValueOf(&unicode.Miao)
		case "Mn":
			return reflect.ValueOf(&unicode.Mn)
		case "Modi":
			return reflect.ValueOf(&unicode.Modi)
		case "Mongolian":
			return reflect.ValueOf(&unicode.Mongolian)
		case "Mro":
			return reflect.ValueOf(&unicode.Mro)
		case "Multani":
			return reflect.ValueOf(&unicode.Multani)
		case "Myanmar":
			return reflect.ValueOf(&unicode.Myanmar)
		case "N":
			return reflect.ValueOf(&unicode.N)
		case "Nabataean":
			return reflect.ValueOf(&unicode.Nabataean)
		case "Nandinagari":
			return reflect.ValueOf(&unicode.Nandinagari)
		case "Nd":
			return reflect.ValueOf(&unicode.Nd)
		case "New_Tai_Lue":
			return reflect.ValueOf(&unicode.New_Tai_Lue)
		case "Newa":
			return reflect.ValueOf(&unicode.Newa)
		case "Nko":
			return reflect.ValueOf(&unicode.Nko)
		case "Nl":
			return reflect.ValueOf(&unicode.Nl)
		case "No":
			return reflect.ValueOf(&unicode.No)
		case "Noncharacter_Code_Point":
			return reflect.ValueOf(&unicode.Noncharacter_Code_Point)
		case "Number":
			return reflect.ValueOf(&unicode.Number)
		case "Nushu":
			return reflect.ValueOf(&unicode.Nushu)
		case "Nyiakeng_Puachue_Hmong":
			return reflect.ValueOf(&unicode.Nyiakeng_Puachue_Hmong)
		case "Ogham":
			return reflect.ValueOf(&unicode.Ogham)
		case "Ol_Chiki":
			return reflect.ValueOf(&unicode.Ol_Chiki)
		case "Old_Hungarian":
			return reflect.ValueOf(&unicode.Old_Hungarian)
		case "Old_Italic":
			return reflect.ValueOf(&unicode.Old_Italic)
		case "Old_North_Arabian":
			return reflect.ValueOf(&unicode.Old_North_Arabian)
		case "Old_Permic":
			return reflect.ValueOf(&unicode.Old_Permic)
		case "Old_Persian":
			return reflect.ValueOf(&unicode.Old_Persian)
		case "Old_Sogdian":
			return reflect.ValueOf(&unicode.Old_Sogdian)
		case "Old_South_Arabian":
			return reflect.ValueOf(&unicode.Old_South_Arabian)
		case "Old_Turkic":
			return reflect.ValueOf(&unicode.Old_Turkic)
		case "Oriya":
			return reflect.ValueOf(&unicode.Oriya)
		case "Osage":
			return reflect.ValueOf(&unicode.Osage)
		case "Osmanya":
			return reflect.ValueOf(&unicode.Osmanya)
		case "Other":
			return reflect.ValueOf(&unicode.Other)
		case "Other_Alphabetic":
			return reflect.ValueOf(&unicode.Other_Alphabetic)
		case "Other_Default_Ignorable_Code_Point":
			return reflect.ValueOf(&unicode.Other_Default_Ignorable_Code_Point)
		case "Other_Grapheme_Extend":
			return reflect.ValueOf(&unicode.Other_Grapheme_Extend)
		case "Other_ID_Continue":
			return reflect.ValueOf(&unicode.Other_ID_Continue)
		case "Other_ID_Start":
			return reflect.ValueOf(&unicode.Other_ID_Start)
		case "Other_Lowercase":
			return reflect.ValueOf(&unicode.Other_Lowercase)
		case "Other_Math":
			return reflect.ValueOf(&unicode.Other_Math)
		case "Other_Uppercase":
			return reflect.ValueOf(&unicode.Other_Uppercase)
		case "P":
			return reflect.ValueOf(&unicode.P)
		case "Pahawh_Hmong":
			return reflect.ValueOf(&unicode.Pahawh_Hmong)
		case "Palmyrene":
			return reflect.ValueOf(&unicode.Palmyrene)
		case "Pattern_Syntax":
			return reflect.ValueOf(&unicode.Pattern_Syntax)
		case "Pattern_White_Space":
			return reflect.ValueOf(&unicode.Pattern_White_Space)
		case "Pau_Cin_Hau":
			return reflect.ValueOf(&unicode.Pau_Cin_Hau)
		case "Pc":
			return reflect.ValueOf(&unicode.Pc)
		case "Pd":
			return reflect.ValueOf(&unicode.Pd)
		case "Pe":
			return reflect.ValueOf(&unicode.Pe)
		case "Pf":
			return reflect.ValueOf(&unicode.Pf)
		case "Phags_Pa":
			return reflect.ValueOf(&unicode.Phags_Pa)
		case "Phoenician":
			return reflect.ValueOf(&unicode.Phoenician)
		case "Pi":
			return reflect.ValueOf(&unicode.Pi)
		case "Po":
			return reflect.ValueOf(&unicode.Po)
		case "Prepended_Concatenation_Mark":
			return reflect.ValueOf(&unicode.Prepended_Concatenation_Mark)
		case "PrintRanges":
			return reflect.ValueOf(&unicode.PrintRanges)
		case "Properties":
			return reflect.ValueOf(&unicode.Properties)
		case "Ps":
			return reflect.ValueOf(&unicode.Ps)
		case "Psalter_Pahlavi":
			return reflect.ValueOf(&unicode.Psalter_Pahlavi)
		case "Punct":
			return reflect.ValueOf(&unicode.Punct)
		case "Quotation_Mark":
			return reflect.ValueOf(&unicode.Quotation_Mark)
		case "Radical":
			return reflect.ValueOf(&unicode.Radical)
		case "Regional_Indicator":
			return reflect.ValueOf(&unicode.Regional_Indicator)
		case "Rejang":
			return reflect.ValueOf(&unicode.Rejang)
		case "Runic":
			return reflect.ValueOf(&unicode.Runic)
		case "S":
			return reflect.ValueOf(&unicode.S)
		case "STerm":
			return reflect.ValueOf(&unicode.STerm)
		case "Samaritan":
			return reflect.ValueOf(&unicode.Samaritan)
		case "Saurashtra":
			return reflect.ValueOf(&unicode.Saurashtra)
		case "Sc":
			return reflect.ValueOf(&unicode.Sc)
		case "Scripts":
			return reflect.ValueOf(&unicode.Scripts)
		case "Sentence_Terminal":
			return reflect.ValueOf(&unicode.Sentence_Terminal)
		case "Sharada":
			return reflect.ValueOf(&unicode.Sharada)
		case "Shavian":
			return reflect.ValueOf(&unicode.Shavian)
		case "Siddham":
			return reflect.ValueOf(&unicode.Siddham)
		case "SignWriting":
			return reflect.ValueOf(&unicode.SignWriting)
		case "SimpleFold":
			return reflect.ValueOf(unicode.SimpleFold)
		case "Sinhala":
			return reflect.ValueOf(&unicode.Sinhala)
		case "Sk":
			return reflect.ValueOf(&unicode.Sk)
		case "Sm":
			return reflect.ValueOf(&unicode.Sm)
		case "So":
			return reflect.ValueOf(&unicode.So)
		case "Soft_Dotted":
			return reflect.ValueOf(&unicode.Soft_Dotted)
		case "Sogdian":
			return reflect.ValueOf(&unicode.Sogdian)
		case "Sora_Sompeng":
			return reflect.ValueOf(&unicode.Sora_Sompeng)
		case "Soyombo":
			return reflect.ValueOf(&unicode.Soyombo)
		case "Space":
			return reflect.ValueOf(&unicode.Space)
		case "Sundanese":
			return reflect.ValueOf(&unicode.Sundanese)
		case "Syloti_Nagri":
			return reflect.ValueOf(&unicode.Syloti_Nagri)
		case "Symbol":
			return reflect.ValueOf(&unicode.Symbol)
		case "Syriac":
			return reflect.ValueOf(&unicode.Syriac)
		case "Tagalog":
			return reflect.ValueOf(&unicode.Tagalog)
		case "Tagbanwa":
			return reflect.ValueOf(&unicode.Tagbanwa)
		case "Tai_Le":
			return reflect.ValueOf(&unicode.Tai_Le)
		case "Tai_Tham":
			return reflect.ValueOf(&unicode.Tai_Tham)
		case "Tai_Viet":
			return reflect.ValueOf(&unicode.Tai_Viet)
		case "Takri":
			return reflect.ValueOf(&unicode.Takri)
		case "Tamil":
			return reflect.ValueOf(&unicode.Tamil)
		case "Tangut":
			return reflect.ValueOf(&unicode.Tangut)
		case "Telugu":
			return reflect.ValueOf(&unicode.Telugu)
		case "Terminal_Punctuation":
			return reflect.ValueOf(&unicode.Terminal_Punctuation)
		case "Thaana":
			return reflect.ValueOf(&unicode.Thaana)
		case "Thai":
			return reflect.ValueOf(&unicode.Thai)
		case "Tibetan":
			return reflect.ValueOf(&unicode.Tibetan)
		case "Tifinagh":
			return reflect.ValueOf(&unicode.Tifinagh)
		case "Tirhuta":
			return reflect.ValueOf(&unicode.Tirhuta)
		case "Title":
			return reflect.ValueOf(&unicode.Title)
		case "To":
			return reflect.ValueOf(unicode.To)
		case "ToLower":
			return reflect.ValueOf(unicode.ToLower)
		case "ToTitle":
			return reflect.ValueOf(unicode.ToTitle)
		case "ToUpper":
			return reflect.ValueOf(unicode.ToUpper)
		case "TurkishCase":
			return reflect.ValueOf(&unicode.TurkishCase)
		case "Ugaritic":
			return reflect.ValueOf(&unicode.Ugaritic)
		case "Unified_Ideograph":
			return reflect.ValueOf(&unicode.Unified_Ideograph)
		case "Upper":
			return reflect.ValueOf(&unicode.Upper)
		case "Vai":
			return reflect.ValueOf(&unicode.Vai)
		case "Variation_Selector":
			return reflect.ValueOf(&unicode.Variation_Selector)
		case "Wancho":
			return reflect.ValueOf(&unicode.Wancho)
		case "Warang_Citi":
			return reflect.ValueOf(&unicode.Warang_Citi)
		case "White_Space":
			return reflect.ValueOf(&unicode.White_Space)
		case "Yezidi":
			return reflect.ValueOf(&unicode.Yezidi)
		case "Yi":
			return reflect.ValueOf(&unicode.Yi)
		case "Z":
			return reflect.ValueOf(&unicode.Z)
		case "Zanabazar_Square":
			return reflect.ValueOf(&unicode.Zanabazar_Square)
		case "Zl":
			return reflect.ValueOf(&unicode.Zl)
		case "Zp":
			return reflect.ValueOf(&unicode.Zp)
		case "Zs":
			return reflect.ValueOf(&unicode.Zs)
		}
	case "unicode/utf16":
		switch topLevelName {
		case "Decode":
			return reflect.ValueOf(utf16.Decode)
		case "DecodeRune":
			return reflect.ValueOf(utf16.DecodeRune)
		case "Encode":
			return reflect.ValueOf(utf16.Encode)
		case "EncodeRune":
			return reflect.ValueOf(utf16.EncodeRune)
		case "IsSurrogate":
			return reflect.ValueOf(utf16.IsSurrogate)
		}
	case "unicode/utf8":
		switch topLevelName {
		case "AppendRune":
			return reflect.ValueOf(utf8.AppendRune)
		case "DecodeLastRune":
			return reflect.ValueOf(utf8.DecodeLastRune)
		case "DecodeLastRuneInString":
			return reflect.ValueOf(utf8.DecodeLastRuneInString)
		case "DecodeRune":
			return reflect.ValueOf(utf8.DecodeRune)
		case "DecodeRuneInString":
			return reflect.ValueOf(utf8.DecodeRuneInString)
		case "EncodeRune":
			return reflect.ValueOf(utf8.EncodeRune)
		case "FullRune":
			return reflect.ValueOf(utf8.FullRune)
		case "FullRuneInString":
			return reflect.ValueOf(utf8.FullRuneInString)
		case "RuneCount":
			return reflect.ValueOf(utf8.RuneCount)
		case "RuneCountInString":
			return reflect.ValueOf(utf8.RuneCountInString)
		case "RuneLen":
			return reflect.ValueOf(utf8.RuneLen)
		case "RuneStart":
			return reflect.ValueOf(utf8.RuneStart)
		case "Valid":
			return reflect.ValueOf(utf8.Valid)
		case "ValidRune":
			return reflect.ValueOf(utf8.ValidRune)
		case "ValidString":
			return reflect.ValueOf(utf8.ValidString)
		}
	}
	return reflect.Value{}
}
